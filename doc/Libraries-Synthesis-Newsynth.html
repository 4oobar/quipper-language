<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Libraries.Synthesis.Newsynth</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Libraries-Synthesis-Newsynth.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Libraries/Synthesis/Newsynth.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Libraries.Synthesis.Newsynth</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Miscellaneous functions
</a></li><li><a href="#g:2">Randomized algorithms
</a></li><li><a href="#g:3">Square roots in &#8484;&#91;&#8730;2&#93;
</a></li><li><a href="#g:4">Roots of &#8722;1 in &#8484;<sub><em>p</em></sub>
</a></li><li><a href="#g:5">Solving a Diophantine equation
</a></li><li><a href="#g:6">Approximations in &#8484;&#91;&#8730;2&#93;
</a></li><li><a href="#g:7">Approximate synthesis
</a><ul><li><a href="#g:8">The main algorithm
</a></li><li><a href="#g:9">User-friendly functions
</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module implements an efficient single-qubit Clifford+<em>T</em>
 approximation algorithm. The algorithm is described here:
</p><ul><li> Peter Selinger. Efficient Clifford+<em>T</em> approximation of
 single-qubit operators. <a href="http://arxiv.org/abs/1212.6253">http://arxiv.org/abs/1212.6253</a>.
</li></ul></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:ensure">ensure</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> ()</li><li class="src short"><a href="#v:maybe_head">maybe_head</a> ::  &#91;a&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:power">power</a> ::  (a -&gt; a -&gt; a) -&gt; a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; a</li><li class="src short"><a href="#v:floorlog">floorlog</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Fractional">Fractional</a> b, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> b) =&gt; b -&gt; b -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>, b)</li><li class="src short"><a href="#v:keeptrying">keeptrying</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; (g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a) -&gt; g -&gt; a</li><li class="src short"><a href="#v:keeptrying_count">keeptrying_count</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; (g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a) -&gt; g -&gt; (a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>)</li><li class="src short"><a href="#v:try_for">try_for</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; (g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a) -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:dinteger_root">dinteger_root</a> :: <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a></li><li class="src short"><a href="#v:root_minus_one_step">root_minus_one_step</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a></li><li class="src short"><a href="#v:root_minus_one">root_minus_one</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a></li><li class="src short"><a href="#v:dioph_step">dioph_step</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a> -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Libraries-Synthesis-Ring.html#t:ZOmega">ZOmega</a></li><li class="src short"><a href="#v:dioph">dioph</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a> -&gt; g -&gt; <a href="Libraries-Synthesis-Ring.html#t:ZOmega">ZOmega</a></li><li class="src short"><a href="#v:gridpoints">gridpoints</a> :: (<a href="Libraries-Synthesis-Ring.html#t:RootTwoRing">RootTwoRing</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Fractional">Fractional</a> r, <a href="Libraries-Synthesis-Ring.html#t:Floor">Floor</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> r, <a href="Libraries-Synthesis-SymReal.html#t:ToReal">ToReal</a> r) =&gt; (r, r) -&gt; (r, r) -&gt; &#91;<a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a>&#93;</li><li class="src short"><a href="#v:gridpoint_random">gridpoint_random</a> :: (<a href="Libraries-Synthesis-Ring.html#t:RootTwoRing">RootTwoRing</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Fractional">Fractional</a> r, <a href="Libraries-Synthesis-Ring.html#t:Floor">Floor</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> r, <a href="Libraries-Synthesis-SymReal.html#t:ToReal">ToReal</a> r, <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g) =&gt; (r, r) -&gt; (r, r) -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a></li><li class="src short"><a href="#v:gridpoint_random_parity">gridpoint_random_parity</a> :: (<a href="Libraries-Synthesis-Ring.html#t:RootTwoRing">RootTwoRing</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Fractional">Fractional</a> r, <a href="Libraries-Synthesis-Ring.html#t:Floor">Floor</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> r, <a href="Libraries-Synthesis-SymReal.html#t:ToReal">ToReal</a> r, <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; (r, r) -&gt; (r, r) -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a></li><li class="src short"><a href="#v:newsynth_step">newsynth_step</a> :: <span class="keyword">forall</span> r g. (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:RealFrac">RealFrac</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Floating">Floating</a> r, <a href="Libraries-Synthesis-Ring.html#t:RootHalfRing">RootHalfRing</a> r, <a href="Libraries-Synthesis-Ring.html#t:Floor">Floor</a> r, <a href="Libraries-Synthesis-Ring.html#t:Adjoint">Adjoint</a> r, <a href="Libraries-Synthesis-SymReal.html#t:ToReal">ToReal</a> r, <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g) =&gt; r -&gt; r -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Libraries-Synthesis-Matrix.html#t:U2">U2</a> <a href="Libraries-Synthesis-Ring.html#t:DOmega">DOmega</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a>)</li><li class="src short"><a href="#v:newsynth">newsynth</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="Libraries-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; <a href="Libraries-Synthesis-Matrix.html#t:U2">U2</a> <a href="Libraries-Synthesis-Ring.html#t:DOmega">DOmega</a></li><li class="src short"><a href="#v:newsynth_stats">newsynth_stats</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="Libraries-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; (<a href="Libraries-Synthesis-Matrix.html#t:U2">U2</a> <a href="Libraries-Synthesis-Ring.html#t:DOmega">DOmega</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>)</li><li class="src short"><a href="#v:newsynth_gates">newsynth_gates</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="Libraries-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; &#91;<a href="Libraries-Synthesis-CliffordT.html#t:Gate">Gate</a>&#93;</li></ul></div><div id="interface"><h1 id="g:1">Miscellaneous functions
</h1><div class="top"><p class="src"><a name="v:ensure" class="def">ensure</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> ()<a href="src/Libraries/Synthesis/Newsynth.html#line-38" class="link">Source</a></p><div class="doc"><p>A useful operation for the <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> monad, used to ensure that
 some condition holds (i.e., return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code> if the condition is
 false). To be used like this:
</p><pre> do
   x &lt;- something
   y &lt;- something_else
   ensure (x &gt; y)
   ...
</pre></div></div><div class="top"><p class="src"><a name="v:maybe_head" class="def">maybe_head</a> ::  &#91;a&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a<a href="src/Libraries/Synthesis/Newsynth.html#line-43" class="link">Source</a></p><div class="doc"><p>Return the head of a list, if non-empty, or else <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:power" class="def">power</a> ::  (a -&gt; a -&gt; a) -&gt; a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; a<a href="src/Libraries/Synthesis/Newsynth.html#line-52" class="link">Source</a></p><div class="doc"><p>Exponentiation via repeated squaring, parameterized by a
 multiplication function and a unit. Given an associative
 multiplication function <code>*</code> with unit <code>e</code>, the function <code><a href="Libraries-Synthesis-Newsynth.html#v:power">power</a></code>
 <code>(*)</code> <em>e</em> <em>a</em> <em>n</em> efficiently computes <em>a</em><sup><em>n</em></sup> = <em>a</em> <code>*</code> (<em>a</em>
 <code>*</code> (&#8230; <code>*</code> (<em>a</em> <code>*</code> <em>e</em>)&#8230;)).
</p></div></div><div class="top"><p class="src"><a name="v:floorlog" class="def">floorlog</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Fractional">Fractional</a> b, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> b) =&gt; b -&gt; b -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>, b)<a href="src/Libraries/Synthesis/Newsynth.html#line-70" class="link">Source</a></p><div class="doc"><p>Given positive numbers <em>b</em> and <em>x</em>, return (<em>n</em>, <em>r</em>) such that
</p><ul><li> <em>x</em> = <em>r</em> <em>b</em><sup><em>n</em></sup> and                           
</li><li> 1 &#8804; <em>r</em> &lt; <em>b</em>.                                  
</li></ul><p>In other words, let <em>n</em> = &#8970;log<sub><em>b</em></sub> <em>x</em>&#8971; and 
 <em>r</em> = <em>x</em> <em>b</em><sup>&#8722;<em>n</em></sup>. This can be more efficient than <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#v:floor">floor</a></code>
 (<code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#v:logBase">logBase</a></code> <em>b</em> <em>x</em>) depending on the type; moreover, it also works
 for exact types such as <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Rational">Rational</a></code> and <code><a href="Libraries-Synthesis-Ring.html#t:EReal">EReal</a></code>.
</p></div></div><h1 id="g:2">Randomized algorithms
</h1><div class="top"><p class="src"><a name="v:keeptrying" class="def">keeptrying</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; (g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a) -&gt; g -&gt; a<a href="src/Libraries/Synthesis/Newsynth.html#line-86" class="link">Source</a></p><div class="doc"><p>A combinator for turning a probabilistic function that succeeds
 with some small probability into a probabilistic function that
 always succeeds, by trying again and again.
</p></div></div><div class="top"><p class="src"><a name="v:keeptrying_count" class="def">keeptrying_count</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; (g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a) -&gt; g -&gt; (a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>)<a href="src/Libraries/Synthesis/Newsynth.html#line-94" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Libraries-Synthesis-Newsynth.html#v:keeptrying">keeptrying</a></code>, but also returns a count of the number of attempts.
</p></div></div><div class="top"><p class="src"><a name="v:try_for" class="def">try_for</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; (g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a) -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a<a href="src/Libraries/Synthesis/Newsynth.html#line-106" class="link">Source</a></p><div class="doc"><p>A combinator for turning a probabilistic function that succeeds
 with some small probability into a probabilistic function that
 succeeds with a higher probability, by repeating it <em>n</em> times. 
</p></div></div><h1 id="g:3">Square roots in &#8484;&#91;&#8730;2&#93;
</h1><div class="top"><p class="src"><a name="v:dinteger_root" class="def">dinteger_root</a> :: <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a><a href="src/Libraries/Synthesis/Newsynth.html#line-120" class="link">Source</a></p><div class="doc"><p>Return a square root of an element of &#8484;&#91;&#8730;2&#93;, if such a square
 root exists, or else <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code>.
</p></div></div><h1 id="g:4">Roots of &#8722;1 in &#8484;<sub><em>p</em></sub>
</h1><div class="top"><p class="src"><a name="v:root_minus_one_step" class="def">root_minus_one_step</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a><a href="src/Libraries/Synthesis/Newsynth.html#line-146" class="link">Source</a></p><div class="doc"><p>Input an integer <em>p</em>, and maybe output a root of &#8722;1 modulo <em>p</em>.
 This succeeds with probability at least 1/2 if <em>p</em> is a positive
 prime &#8801; 1 (mod 4); otherwise, the success probability is
 unspecified (and may be 0).
</p></div></div><div class="top"><p class="src"><a name="v:root_minus_one" class="def">root_minus_one</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a><a href="src/Libraries/Synthesis/Newsynth.html#line-157" class="link">Source</a></p><div class="doc"><p>Input a positive prime <em>p</em> &#8801; 1 (mod 4), and output a root of &#8722;1.
</p></div></div><h1 id="g:5">Solving a Diophantine equation
</h1><div class="top"><p class="src"><a name="v:dioph_step" class="def">dioph_step</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a> -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Libraries-Synthesis-Ring.html#t:ZOmega">ZOmega</a><a href="src/Libraries/Synthesis/Newsynth.html#line-168" class="link">Source</a></p><div class="doc"><p>Input &#958; &#8712; &#8484;&#91;&#8730;2&#93;, and maybe output some t &#8712; &#8484;&#91;&#969;&#93; such that 
 t<sup>&#8224;</sup>t = &#958;. If &#958; &#8805; 0, &#958;<sup>&#8226;</sup> &#8805; 0, and <em>p</em> = &#958;<sup>&#8226;</sup>&#958; is a
 prime &#8801; 1 (mod 4) in &#8484;, then this succeeds with probability at least
 1/2.  Otherwise, the success probability is unspecified and may be
 0.
</p></div></div><div class="top"><p class="src"><a name="v:dioph" class="def">dioph</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a> -&gt; g -&gt; <a href="Libraries-Synthesis-Ring.html#t:ZOmega">ZOmega</a><a href="src/Libraries/Synthesis/Newsynth.html#line-183" class="link">Source</a></p><div class="doc"><p>Input &#958; &#8712; &#8484;&#91;&#8730;2&#93; such that &#958; &#8805; 0, &#958;<sup>&#8226;</sup> &#8805; 0, and <em>p</em> = 
 &#958;<sup>&#8226;</sup>&#958; is a prime &#8801; 1 (mod 4) in &#8484;. Output t &#8712; &#8484;&#91;&#969;&#93; such that
 t<sup>&#8224;</sup>t = &#958;. If the hypotheses are not satisfied, this will
 likely loop forever.
</p></div></div><h1 id="g:6">Approximations in &#8484;&#91;&#8730;2&#93;
</h1><div class="top"><p class="src"><a name="v:gridpoints" class="def">gridpoints</a> :: (<a href="Libraries-Synthesis-Ring.html#t:RootTwoRing">RootTwoRing</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Fractional">Fractional</a> r, <a href="Libraries-Synthesis-Ring.html#t:Floor">Floor</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> r, <a href="Libraries-Synthesis-SymReal.html#t:ToReal">ToReal</a> r) =&gt; (r, r) -&gt; (r, r) -&gt; &#91;<a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a>&#93;<a href="src/Libraries/Synthesis/Newsynth.html#line-202" class="link">Source</a></p><div class="doc"><p>Input two intervals &#91;<em>x</em>&#8320;, <em>x</em>&#8321;&#93; &#8838; &#8477; and &#91;<em>y</em>&#8320;, <em>y</em>&#8321;&#93; &#8838; &#8477;. Output
 a list of all points <em>z</em> = <em>a</em> + &#8730;2<em>b</em> &#8712; &#8484;&#91;&#8730;2&#93; such that <em>z</em> &#8712;
 &#91;<em>x</em>&#8320;, <em>x</em>&#8321;&#93; and <em>z</em><sup>&#8226;</sup> &#8712; &#91;<em>y</em>&#8320;, <em>y</em>&#8321;&#93;. The list will be
 produced lazily, and will be sorted in order of increasing <em>z</em>.
</p><p>It is a theorem that there will be at least one solution if &#916;x&#916;y &#8805; (1
 + &#8730;2)&#178;, and at most one solution if &#916;x&#916;y &lt; 1, where &#916;x = <em>x</em>&#8321; &#8722; <em>x</em>&#8320; &#8805; 0
 and &#916;y = <em>y</em>&#8321; &#8722; <em>y</em>&#8320; &#8805; 0. Asymptotically, the expected number of
 solutions is &#916;x&#916;y/&#8730;8.
</p><p>This function is formulated so that the intervals can be specified
 exactly (using a type such as <code><a href="Libraries-Synthesis-Ring.html#t:EReal">EReal</a></code>), or approximately (using a
 type such as <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></code> or <code><a href="http://hackage.haskell.org/packages/archive/fixedprec/0.2/doc/html/Data-Number-FixedPrec.html#t:FixedPrec">FixedPrec</a></code> <em>e</em>).
</p></div></div><div class="top"><p class="src"><a name="v:gridpoint_random" class="def">gridpoint_random</a> :: (<a href="Libraries-Synthesis-Ring.html#t:RootTwoRing">RootTwoRing</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Fractional">Fractional</a> r, <a href="Libraries-Synthesis-Ring.html#t:Floor">Floor</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> r, <a href="Libraries-Synthesis-SymReal.html#t:ToReal">ToReal</a> r, <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g) =&gt; (r, r) -&gt; (r, r) -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a><a href="src/Libraries/Synthesis/Newsynth.html#line-252" class="link">Source</a></p><div class="doc"><p>Input two intervals &#91;<em>x</em>&#8320;, <em>x</em>&#8321;&#93; &#8838; &#8477; and &#91;<em>y</em>&#8320;, <em>y</em>&#8321;&#93; &#8838; &#8477; and a
 source of randomness. Output a random element <em>z</em> = <em>a</em> + &#8730;2<em>b</em>
 &#8712; &#8484;&#91;&#8730;2&#93; such that <em>z</em> &#8712; &#91;<em>x</em>&#8320;, <em>x</em>&#8321;&#93; and <em>z</em><sup>&#8226;</sup> &#8712; [<em>y</em>&#8320;,
 <em>y</em>&#8321;]. 
</p><p>Note: the randomness will not be uniform. To ensure that the set of
 solutions is non-empty, we must have &#916;x&#916;y &#8805; (1 + &#8730;2)&#178;, where &#916;x =
 <em>x</em>&#8321; &#8722; <em>x</em>&#8320; &#8805; 0 and &#916;y = <em>y</em>&#8321; &#8722; <em>y</em>&#8320; &#8805; 0. If there are no solutions
 at all, the function will return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code>.
</p><p>This function is formulated so that the intervals can be specified
 exactly (using a type such as <code><a href="Libraries-Synthesis-Ring.html#t:EReal">EReal</a></code>), or approximately (using a
 type such as <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></code> or <code><a href="http://hackage.haskell.org/packages/archive/fixedprec/0.2/doc/html/Data-Number-FixedPrec.html#t:FixedPrec">FixedPrec</a></code> <em>e</em>).
</p></div></div><div class="top"><p class="src"><a name="v:gridpoint_random_parity" class="def">gridpoint_random_parity</a> :: (<a href="Libraries-Synthesis-Ring.html#t:RootTwoRing">RootTwoRing</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Fractional">Fractional</a> r, <a href="Libraries-Synthesis-Ring.html#t:Floor">Floor</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> r, <a href="Libraries-Synthesis-SymReal.html#t:ToReal">ToReal</a> r, <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; (r, r) -&gt; (r, r) -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a><a href="src/Libraries/Synthesis/Newsynth.html#line-277" class="link">Source</a></p><div class="doc"><p>Input an integer <em>e</em>, two intervals &#91;<em>x</em>&#8320;, <em>x</em>&#8321;&#93; &#8838; &#8477; and [<em>y</em>&#8320;,
 <em>y</em>&#8321;] &#8838; &#8477;, and a source of randomness. Output random <em>z</em> = <em>a</em> +
 &#8730;2<em>b</em> &#8712; &#8484;&#91;&#8730;2&#93; such that <em>a</em> + &#8730;2<em>b</em> &#8712; &#91;<em>x</em>&#8320;, <em>x</em>&#8321;&#93;, <em>a</em> - &#8730;2<em>b</em> &#8712;
 &#91;<em>y</em>&#8320;, <em>y</em>&#8321;&#93;, and <em>a</em>-<em>e</em> is even.
</p><p>Note: the randomness will not be uniform. To ensure that the set of
 solutions is non-empty, we must have &#916;x&#916;y &#8805; 2(&#8730;2 + 1)&#178;, where &#916;x =
 <em>x</em>&#8321; &#8722; <em>x</em>&#8320; &#8805; 0 and &#916;y = <em>y</em>&#8321; &#8722; <em>y</em>&#8320; &#8805; 0. If there are no solutions
 at all, the function will return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code>.
</p><p>This function is formulated so that the intervals can be specified
 exactly (using a type such as <code><a href="Libraries-Synthesis-Ring.html#t:EReal">EReal</a></code>), or approximately (using a
 type such as <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></code> or <code><a href="http://hackage.haskell.org/packages/archive/fixedprec/0.2/doc/html/Data-Number-FixedPrec.html#t:FixedPrec">FixedPrec</a></code> <em>e</em>).
</p></div></div><h1 id="g:7">Approximate synthesis
</h1><h2 id="g:8">The main algorithm
</h2><div class="top"><p class="src"><a name="v:newsynth_step" class="def">newsynth_step</a> :: <span class="keyword">forall</span> r g. (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:RealFrac">RealFrac</a> r, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Floating">Floating</a> r, <a href="Libraries-Synthesis-Ring.html#t:RootHalfRing">RootHalfRing</a> r, <a href="Libraries-Synthesis-Ring.html#t:Floor">Floor</a> r, <a href="Libraries-Synthesis-Ring.html#t:Adjoint">Adjoint</a> r, <a href="Libraries-Synthesis-SymReal.html#t:ToReal">ToReal</a> r, <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g) =&gt; r -&gt; r -&gt; g -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Libraries-Synthesis-Matrix.html#t:U2">U2</a> <a href="Libraries-Synthesis-Ring.html#t:DOmega">DOmega</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a>)<a href="src/Libraries/Synthesis/Newsynth.html#line-320" class="link">Source</a></p><div class="doc"><p>The internal implementation of the approximate synthesis
 algorithm. The parameters are:
</p><ul><li> an angle &#952;, to implement a <em>R</em><sub><em>z</em></sub>(&#952;) = <i>e</i><sup>&#8722;<em>i</em>&#952;<em>Z</em>/2</sup>
 gate;
</li><li> a precision <em>p</em> &#8805; 0 in bits, such that &#949; = 2<sup>-<em>p</em></sup>;
</li><li> a source of randomness <em>g</em>.
</li></ul><p>With some probability, output a unitary operator in the
 Clifford+<em>T</em> group that approximates <em>R</em><sub><em>z</em></sub>(&#952;) to within &#949; in
 the operator norm. This operator can then be converted to a list of
 gates with <code><a href="Libraries-Synthesis-CliffordT.html#v:to_gates">to_gates</a></code>. Also output log<sub>0.1</sub> of the actual
 error, or <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code> if the error is 0.
</p><p>This implementation does not use seeding.
</p><p>As a special case, if the <em>R</em><sub><em>z</em></sub>(&#952;) is a Clifford operator
 (to within the given &#949;), always return this operator directly.
</p><p>Note: the parameter &#952; must be of a real number type that has enough
 precision to perform intermediate calculations; the typically
 requires precision O(&#949;<sup>2</sup>).  A more user-friendly function that
 does this automatically is <code><a href="Libraries-Synthesis-Newsynth.html#v:newsynth">newsynth</a></code>.
</p></div></div><h2 id="g:9">User-friendly functions
</h2><div class="top"><p class="src"><a name="v:newsynth" class="def">newsynth</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="Libraries-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; <a href="Libraries-Synthesis-Matrix.html#t:U2">U2</a> <a href="Libraries-Synthesis-Ring.html#t:DOmega">DOmega</a><a href="src/Libraries/Synthesis/Newsynth.html#line-437" class="link">Source</a></p><div class="doc"><p>A user-friendly interface to the approximate synthesis
 algorithm. The parameters are:
</p><ul><li> an angle &#952;, to implement a <em>R</em><sub><em>z</em></sub>(&#952;) = <i>e</i><sup>&#8722;<em>i</em>&#952;<em>Z</em>/2</sup>
 gate;
</li><li> a precision <em>b</em> &#8805; 0 in bits, such that &#949; = 2<sup>-<em>b</em></sup>;
</li><li> a source of randomness <em>g</em>.
</li></ul><p>Output a unitary operator in the Clifford+<em>T</em> group that
 approximates <em>R</em><sub><em>z</em></sub>(&#952;) to within &#949; in the operator norm. This
 operator can then be converted to a list of gates with
 <code><a href="Libraries-Synthesis-CliffordT.html#v:to_gates">to_gates</a></code>.
</p><p>This implementation does not use seeding.
</p><p>Note: the argument <em>theta</em> is given as a symbolic real number. It
 will automatically be expanded to as many digits as are necessary
 for the internal calculation. In this way, the caller can specify,
 e.g., an angle of <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#v:pi">pi</a></code>/128 <code>::</code> <code><a href="Libraries-Synthesis-SymReal.html#t:SymReal">SymReal</a></code>, without having to worry
 about how many digits of &#960; to specify.
</p></div></div><div class="top"><p class="src"><a name="v:newsynth_stats" class="def">newsynth_stats</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="Libraries-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; (<a href="Libraries-Synthesis-Matrix.html#t:U2">U2</a> <a href="Libraries-Synthesis-Ring.html#t:DOmega">DOmega</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>)<a href="src/Libraries/Synthesis/Newsynth.html#line-444" class="link">Source</a></p><div class="doc"><p>A version of <code><a href="Libraries-Synthesis-Newsynth.html#v:newsynth">newsynth</a></code> that also returns some statistics:
 log<sub>0.1</sub> of the actual approximation error (or <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code> if the
 error is 0), and the number of candidates tried.
</p></div></div><div class="top"><p class="src"><a name="v:newsynth_gates" class="def">newsynth_gates</a> :: <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="Libraries-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; &#91;<a href="Libraries-Synthesis-CliffordT.html#t:Gate">Gate</a>&#93;<a href="src/Libraries/Synthesis/Newsynth.html#line-456" class="link">Source</a></p><div class="doc"><p>A version of <code><a href="Libraries-Synthesis-Newsynth.html#v:newsynth">newsynth</a></code> that returns a list of gates instead of a
 matrix. The inputs are the same as for <code><a href="Libraries-Synthesis-Newsynth.html#v:newsynth">newsynth</a></code>.
</p><p>Note: the list of gates will be returned in right-to-left order,
 i.e., as in the mathematical notation for matrix multiplication.
 This is the opposite of the quantum circuit notation.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>
