<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Libraries.Synthesis.RotationDecomposition</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Libraries-Synthesis-RotationDecomposition.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Libraries/Synthesis/RotationDecomposition.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Libraries.Synthesis.RotationDecomposition</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Elementary rotations
</a></li><li><a href="#g:2">Decomposition into elementary rotations
</a></li><li><a href="#g:3">Auxiliary functions
</a></li><li><a href="#g:4">Testing
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides functions for decomposing a unitary <em>n</em>&#215;<em>n</em>
 operator into one- and two-level unitaries. 
</p><p>The algorithm is adapted from Section 4.5.1 of Nielsen and
 Chuang. In addition to what is described in Nielsen and Chuang, our
 algorithm produces two-level operators that can be decomposed using
 only two Euler angles. The algorithm produces at most <em>n</em>(<em>n</em>&#8722;1)/2
 two-level operators of type <em>R</em><sub><em>z</em></sub>(&#948;)<em>R</em><sub><em>x</em></sub>(&#947;), as well
 as <em>n</em> one-level operators of type <i>e</i><sup><em>i</em>&#952;</sup>. Therefore, the
 decomposition of a unitary <em>n</em>&#215;<em>n</em> operator yields <em>n</em><sup>2</sup> real
 parameters, which is optimal.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:ElementaryRot">ElementaryRot</a> a<ul class="subs"><li>= <a href="#v:ERot_zx">ERot_zx</a> a a <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a> <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a>  </li><li>| <a href="#v:ERot_phase">ERot_phase</a> a <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a>  </li></ul></li><li class="src short"><a href="#v:matrix_of_elementary">matrix_of_elementary</a> :: (<a href="Libraries-Synthesis-Ring.html#t:Ring">Ring</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Floating">Floating</a> a, <a href="Libraries-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; <a href="Libraries-Synthesis-RotationDecomposition.html#t:ElementaryRot">ElementaryRot</a> a -&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a)</li><li class="src short"><a href="#v:matrix_of_elementaries">matrix_of_elementaries</a> :: (<a href="Libraries-Synthesis-Ring.html#t:Ring">Ring</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Floating">Floating</a> a, <a href="Libraries-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; &#91;<a href="Libraries-Synthesis-RotationDecomposition.html#t:ElementaryRot">ElementaryRot</a> a&#93; -&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a)</li><li class="src short"><a href="#v:rotation_decomposition">rotation_decomposition</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Fractional">Fractional</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Floating">Floating</a> a, <a href="Libraries-Synthesis-Ring.html#t:Adjoint">Adjoint</a> a, <a href="Libraries-Synthesis-ArcTan2.html#t:ArcTan2">ArcTan2</a> a, <a href="Libraries-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a) -&gt; &#91;<a href="Libraries-Synthesis-RotationDecomposition.html#t:ElementaryRot">ElementaryRot</a> a&#93;</li><li class="src short"><a href="#v:twolevel_matrix_of_matrix">twolevel_matrix_of_matrix</a> :: (<a href="Libraries-Synthesis-Ring.html#t:Ring">Ring</a> a, <a href="Libraries-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> <a href="Libraries-Synthesis-Matrix.html#t:Two">Two</a> <a href="Libraries-Synthesis-Matrix.html#t:Two">Two</a> a -&gt; <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a> -&gt; <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a> -&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n a</li><li class="src short"><a href="#v:get_phase">get_phase</a> :: <a href="Libraries-Synthesis-ArcTan2.html#t:ArcTan2">ArcTan2</a> a =&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a) -&gt; <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a> -&gt; <a href="Libraries-Synthesis-RotationDecomposition.html#t:ElementaryRot">ElementaryRot</a> a</li><li class="src short"><a href="#v:rowop">rowop</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Fractional">Fractional</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Floating">Floating</a> a, <a href="Libraries-Synthesis-Ring.html#t:Adjoint">Adjoint</a> a, <a href="Libraries-Synthesis-ArcTan2.html#t:ArcTan2">ArcTan2</a> a, <a href="Libraries-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a) -&gt; (<a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a>, <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a>) -&gt; (<a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a), &#91;<a href="Libraries-Synthesis-RotationDecomposition.html#t:ElementaryRot">ElementaryRot</a> a&#93;)</li><li class="src short"><a href="#v:random_unitary">random_unitary</a> :: (<a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Libraries-Synthesis-Matrix.html#t:Nat">Nat</a> n, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Floating">Floating</a> a, <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:Random">Random</a> a) =&gt; g -&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a)</li><li class="src short"><a href="#v:test">test</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()</li></ul></div><div id="interface"><h1 id="g:1">Elementary rotations
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ElementaryRot" class="def">ElementaryRot</a> a <a href="src/Libraries/Synthesis/RotationDecomposition.html#line-45" class="link">Source</a></p><div class="doc"><p>An elementary rotation is either a combined <em>x</em>- and
 <em>z</em>-rotation, applied at indices <em>j</em> and <em>k</em>, or a phase change
 applied at index <em>j</em>.
</p><ul><li> <code><a href="Libraries-Synthesis-RotationDecomposition.html#v:ERot_zx">ERot_zx</a></code> &#948; &#947; <em>j</em> <em>k</em> represents the operator 
 <em>R</em><sub><em>z</em></sub>(&#948;)<em>R</em><sub><em>x</em></sub>(&#947;), applied to levels <em>j</em> and <em>k</em>.
</li></ul><p><img src="images/ERot_zx.png">
</p><ul><li> <code><a href="Libraries-Synthesis-RotationDecomposition.html#v:ERot_phase">ERot_phase</a></code> &#952; <em>j</em> represents the operator <i>e</i><sup><em>i</em>&#952;</sup> applied to level
 <em>j</em>.
</li></ul><p><img src="images/ERot_phase.png">
</p><p>Note: when we use a list of <code><a href="Libraries-Synthesis-RotationDecomposition.html#t:ElementaryRot">ElementaryRot</a></code>s to express a sequence of
 operators, the operators are meant to be applied right-to-left,
 i.e., as in the mathematical notation for matrix multiplication.
 This is the opposite of the quantum circuit notation.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ERot_zx" class="def">ERot_zx</a> a a <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a> <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:ERot_phase" class="def">ERot_phase</a> a <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:ElementaryRot" class="caption collapser" onclick="toggleSection('i:ElementaryRot')">Instances</p><div id="section.i:ElementaryRot" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Libraries-Synthesis-RotationDecomposition.html#t:ElementaryRot">ElementaryRot</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:matrix_of_elementary" class="def">matrix_of_elementary</a> :: (<a href="Libraries-Synthesis-Ring.html#t:Ring">Ring</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Floating">Floating</a> a, <a href="Libraries-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; <a href="Libraries-Synthesis-RotationDecomposition.html#t:ElementaryRot">ElementaryRot</a> a -&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a)<a href="src/Libraries/Synthesis/RotationDecomposition.html#line-51" class="link">Source</a></p><div class="doc"><p>Convert a symbolic elementary rotation to a concrete matrix.
</p></div></div><div class="top"><p class="src"><a name="v:matrix_of_elementaries" class="def">matrix_of_elementaries</a> :: (<a href="Libraries-Synthesis-Ring.html#t:Ring">Ring</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Floating">Floating</a> a, <a href="Libraries-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; &#91;<a href="Libraries-Synthesis-RotationDecomposition.html#t:ElementaryRot">ElementaryRot</a> a&#93; -&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a)<a href="src/Libraries/Synthesis/RotationDecomposition.html#line-70" class="link">Source</a></p><div class="doc"><p>Convert a sequence of elementary rotations to an <em>n</em>&#215;<em>n</em>-matrix.
</p></div></div><h1 id="g:2">Decomposition into elementary rotations
</h1><div class="top"><p class="src"><a name="v:rotation_decomposition" class="def">rotation_decomposition</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Fractional">Fractional</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Floating">Floating</a> a, <a href="Libraries-Synthesis-Ring.html#t:Adjoint">Adjoint</a> a, <a href="Libraries-Synthesis-ArcTan2.html#t:ArcTan2">ArcTan2</a> a, <a href="Libraries-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a) -&gt; &#91;<a href="Libraries-Synthesis-RotationDecomposition.html#t:ElementaryRot">ElementaryRot</a> a&#93;<a href="src/Libraries/Synthesis/RotationDecomposition.html#line-83" class="link">Source</a></p><div class="doc"><p>Convert an <em>n</em>&#215;<em>n</em>-matrix to a sequence of elementary rotations.
</p><p>Note: the list of elementary rotations will be returned in
 right-to-left order, i.e., as in the mathematical notation for
 matrix multiplication.  This is the opposite of the quantum circuit
 notation.
</p></div></div><h1 id="g:3">Auxiliary functions
</h1><div class="top"><p class="src"><a name="v:twolevel_matrix_of_matrix" class="def">twolevel_matrix_of_matrix</a> :: (<a href="Libraries-Synthesis-Ring.html#t:Ring">Ring</a> a, <a href="Libraries-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> <a href="Libraries-Synthesis-Matrix.html#t:Two">Two</a> <a href="Libraries-Synthesis-Matrix.html#t:Two">Two</a> a -&gt; <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a> -&gt; <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a> -&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n a<a href="src/Libraries/Synthesis/RotationDecomposition.html#line-95" class="link">Source</a></p><div class="doc"><p>Construct a two-level <em>n</em>&#215;<em>n</em>-matrix from a given 2&#215;2-matrix and
 indices <em>j</em> and <em>k</em>.
</p></div></div><div class="top"><p class="src"><a name="v:get_phase" class="def">get_phase</a> :: <a href="Libraries-Synthesis-ArcTan2.html#t:ArcTan2">ArcTan2</a> a =&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a) -&gt; <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a> -&gt; <a href="Libraries-Synthesis-RotationDecomposition.html#t:ElementaryRot">ElementaryRot</a> a<a href="src/Libraries/Synthesis/RotationDecomposition.html#line-102" class="link">Source</a></p><div class="doc"><p>Extract the phase of the <em>j</em>th diagonal entry of the given
 matrix.
</p></div></div><div class="top"><p class="src"><a name="v:rowop" class="def">rowop</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Fractional">Fractional</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Floating">Floating</a> a, <a href="Libraries-Synthesis-Ring.html#t:Adjoint">Adjoint</a> a, <a href="Libraries-Synthesis-ArcTan2.html#t:ArcTan2">ArcTan2</a> a, <a href="Libraries-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a) -&gt; (<a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a>, <a href="Libraries-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a>) -&gt; (<a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a), &#91;<a href="Libraries-Synthesis-RotationDecomposition.html#t:ElementaryRot">ElementaryRot</a> a&#93;)<a href="src/Libraries/Synthesis/RotationDecomposition.html#line-112" class="link">Source</a></p><div class="doc"><p>Perform a two-level operation on rows <em>j</em> and <em>k</em> of a matrix <em>U</em>,
 such that the resulting matrix has a 0 in the (<em>j</em>,<em>k</em>)-position.
 Return the inverse of the two-level operation used, as well as the
 updated matrix.
</p></div></div><h1 id="g:4">Testing
</h1><div class="top"><p class="src"><a name="v:random_unitary" class="def">random_unitary</a> :: (<a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Libraries-Synthesis-Matrix.html#t:Nat">Nat</a> n, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Floating">Floating</a> a, <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:Random">Random</a> a) =&gt; g -&gt; <a href="Libraries-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n (<a href="Libraries-Synthesis-Ring.html#t:Cplx">Cplx</a> a)<a href="src/Libraries/Synthesis/RotationDecomposition.html#line-131" class="link">Source</a></p><div class="doc"><p>Return a &quot;random&quot; unitary <em>n</em>&#215;<em>n</em>-matrix. These matrices will
 not quite be uniformly distributed; this function is primarily
 meant to generate test cases. 
</p></div></div><div class="top"><p class="src"><a name="v:test" class="def">test</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()<a href="src/Libraries/Synthesis/RotationDecomposition.html#line-151" class="link">Source</a></p><div class="doc"><p>Generate a random matrix, decompose it, and then re-calculate the
 matrix from the decomposition.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>
