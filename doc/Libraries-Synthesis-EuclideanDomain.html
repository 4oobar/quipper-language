<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Libraries.Synthesis.EuclideanDomain</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Libraries-Synthesis-EuclideanDomain.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Libraries/Synthesis/EuclideanDomain.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Libraries.Synthesis.EuclideanDomain</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Euclidean domains
</a><ul><li><a href="#g:2">Definition
</a></li><li><a href="#g:3">Functions
</a></li></ul></li><li><a href="#g:4">Auxiliary functions
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides a type class for Euclidean domains. A
 Euclidean domain is a ring with a notion of division with
 remainder, and therefore greatest common divisors.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> a, <a href="Libraries-Synthesis-Ring.html#t:Ring">Ring</a> a) =&gt; <a href="#t:EuclideanDomain">EuclideanDomain</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:rank">rank</a> :: a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a></li><li><a href="#v:divmod">divmod</a> :: a -&gt; a -&gt; (a, a)</li></ul></li><li class="src short"><a href="#v:euclid_mod">euclid_mod</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; a -&gt; a</li><li class="src short"><a href="#v:euclid_div">euclid_div</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; a -&gt; a</li><li class="src short"><a href="#v:euclid_gcd">euclid_gcd</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; a -&gt; a</li><li class="src short"><a href="#v:extended_euclid">extended_euclid</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; a -&gt; (a, a, a, a, a)</li><li class="src short"><a href="#v:euclid_inverse">euclid_inverse</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:is_unit">is_unit</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:inv_mod">inv_mod</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:rounddiv">rounddiv</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; a -&gt; a</li></ul></div><div id="interface"><h1 id="g:1">Euclidean domains
</h1><h2 id="g:2">Definition
</h2><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> a, <a href="Libraries-Synthesis-Ring.html#t:Ring">Ring</a> a) =&gt; <a name="t:EuclideanDomain" class="def">EuclideanDomain</a> a  <span class="keyword">where</span><a href="src/Libraries/Synthesis/EuclideanDomain.html#line-20" class="link">Source</a></p><div class="doc"><p>A type class for Euclidean domains. A Euclidean domain is a ring
 with a Euclidean function and a division with remainder.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:rank" class="def">rank</a> :: a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a><a href="src/Libraries/Synthesis/EuclideanDomain.html#line-20" class="link">Source</a></p><div class="doc"><p>The Euclidean function for the Euclidean domain. This is a
 function <em>rank</em> : <em>R</em>\{0} &#8594; &#8469; such that:
</p><ul><li> for all nonzero <em>a</em>, <em>b</em> &#8712; <em>R</em>, <em>rank</em>(<em>a</em>) &#8804; <em>rank</em>(<em>ab</em>);
</li><li> if <em>b</em> &#8800; 0 and (<em>q</em>,<em>r</em>) = <em>a</em> <code><a href="Libraries-Synthesis-EuclideanDomain.html#v:divmod">divmod</a></code> <em>b</em>, then either <em>r</em> =
 0 or <em>rank</em>(<em>r</em>) &lt; <em>rank</em>(<em>b</em>).
</li></ul></div><p class="src"><a name="v:divmod" class="def">divmod</a> :: a -&gt; a -&gt; (a, a)<a href="src/Libraries/Synthesis/EuclideanDomain.html#line-20" class="link">Source</a></p><div class="doc"><p>Given <em>a</em> and <em>b</em>&#8800;0, return a quotient and remainder for
 division of <em>a</em> by <em>b</em>. Specifically, return (<em>q</em>,<em>r</em>) such that
 <em>a</em> = <em>qb</em> + <em>r</em>, and such that <em>r</em> = 0 or <em>rank</em>(<em>r</em>) &lt; <em>rank</em>(<em>b</em>).
</p></div></div><div class="subs instances"><p id="control.i:EuclideanDomain" class="caption collapser" onclick="toggleSection('i:EuclideanDomain')">Instances</p><div id="section.i:EuclideanDomain" class="show"><table><tr><td class="src"><a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> <a href="Libraries-Synthesis-Ring.html#t:ZOmega">ZOmega</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> <a href="Libraries-Synthesis-Ring.html#t:ZComplex">ZComplex</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> <a href="Libraries-Synthesis-Ring.html#t:DInteger">DInteger</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:3">Functions
</h2><div class="top"><p class="src"><a name="v:euclid_mod" class="def">euclid_mod</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; a -&gt; a<a href="src/Libraries/Synthesis/EuclideanDomain.html#line-77" class="link">Source</a></p><div class="doc"><p>Calculate the remainder for the division of <em>x</em> by <em>y</em>.
</p></div></div><div class="top"><p class="src"><a name="v:euclid_div" class="def">euclid_div</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; a -&gt; a<a href="src/Libraries/Synthesis/EuclideanDomain.html#line-86" class="link">Source</a></p><div class="doc"><p>Calculate the quotient for the division of <em>x</em> by <em>y</em>, ignoring
 the remainder, if any. This is typically, but not always, used in
 situations where the remainder is known to be 0 ahead of time.
</p></div></div><div class="top"><p class="src"><a name="v:euclid_gcd" class="def">euclid_gcd</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; a -&gt; a<a href="src/Libraries/Synthesis/EuclideanDomain.html#line-93" class="link">Source</a></p><div class="doc"><p>Calculate the greatest common divisor in any Euclidean domain.
</p></div></div><div class="top"><p class="src"><a name="v:extended_euclid" class="def">extended_euclid</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; a -&gt; (a, a, a, a, a)<a href="src/Libraries/Synthesis/EuclideanDomain.html#line-109" class="link">Source</a></p><div class="doc"><p>Perform the extended Euclidean algorithm. On inputs <em>x</em> and
 <em>y</em>, this returns (<em>a</em>,<em>b</em>,<em>s</em>,<em>t</em>,<em>d</em>) such that:
</p><ul><li> <em>d</em> = gcd(<em>x</em>,<em>y</em>),
</li><li> <em>ax</em> + <em>by</em> = <em>d</em>,
</li><li> <em>sx</em> + <em>ty</em> = 0,
</li><li> <em>at</em> - <em>bs</em> = 1.
</li></ul></div></div><div class="top"><p class="src"><a name="v:euclid_inverse" class="def">euclid_inverse</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a<a href="src/Libraries/Synthesis/EuclideanDomain.html#line-118" class="link">Source</a></p><div class="doc"><p>Find the inverse of a unit in a Euclidean domain. If the given
 element is not a unit, return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:is_unit" class="def">is_unit</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Libraries/Synthesis/EuclideanDomain.html#line-127" class="link">Source</a></p><div class="doc"><p>Determine whether an element of a Euclidean domain is a unit.
</p></div></div><div class="top"><p class="src"><a name="v:inv_mod" class="def">inv_mod</a> :: <a href="Libraries-Synthesis-EuclideanDomain.html#t:EuclideanDomain">EuclideanDomain</a> a =&gt; a -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> a<a href="src/Libraries/Synthesis/EuclideanDomain.html#line-133" class="link">Source</a></p><div class="doc"><p>Compute the inverse of <em>a</em> in <em>R</em>/(p), where <em>R</em> is a Euclidean
 domain. Note: this works whenever <em>a</em> and <em>p</em> are relatively
 prime. If <em>a</em> and <em>p</em> are not relatively prime, return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code>.
</p></div></div><h1 id="g:4">Auxiliary functions
</h1><div class="top"><p class="src"><a name="v:rounddiv" class="def">rounddiv</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; a -&gt; a<a href="src/Libraries/Synthesis/EuclideanDomain.html#line-147" class="link">Source</a></p><div class="doc"><p>For <em>y</em> &#8800; 0, find the integer <em>q</em> closest to <em>x</em> / <em>y</em>. This
 works regardless of whether <em>x</em> and/or <em>y</em> are positive or
 negative.  The distance <em>q</em> &#8722; <em>x</em> / <em>y</em> is guaranteed to be in
 (-1/2, 1/2].
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>
