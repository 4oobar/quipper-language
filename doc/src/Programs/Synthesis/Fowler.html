<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>{-# LANGUAGE BangPatterns #-}</i></font>
<a name="line-2"></a>
<a name="line-3"></a><font color=Blue><i>-- | This module implements a variant of Fowler's algorithm for</i></font>
<a name="line-4"></a><font color=Blue><i>-- optimally approximating any single-qubit gate by Clifford + /T/</i></font>
<a name="line-5"></a><font color=Blue><i>-- gates with precision &#948; [Fowler 2010,</i></font>
<a name="line-6"></a><font color=Blue><i>-- &lt;<a href="http://arxiv.org/abs/quant-ph/0411206v2">http://arxiv.org/abs/quant-ph/0411206v2</a>&gt;].</i></font>
<a name="line-7"></a><font color=Blue><i>-- </i></font>
<a name="line-8"></a><font color=Blue><i>-- This is experimental.</i></font>
<a name="line-9"></a>
<a name="line-10"></a><font color=Green><u>module</u></font> Programs<font color=Cyan>.</font>Synthesis<font color=Cyan>.</font>Fowler <font color=Green><u>where</u></font>
<a name="line-11"></a>
<a name="line-12"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Complex
<a name="line-13"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>List
<a name="line-14"></a><font color=Green><u>import</u></font> System<font color=Cyan>.</font>Random
<a name="line-15"></a><font color=Green><u>import</u></font> System<font color=Cyan>.</font>Environment
<a name="line-16"></a><font color=Green><u>import</u></font> System<font color=Cyan>.</font>IO
<a name="line-17"></a>
<a name="line-18"></a><font color=Blue><i>-- * Overview </i></font>
<a name="line-19"></a>
<a name="line-20"></a><font color=Blue><i>-- $ We use an exhaustive enumeration of all shortest circuits of a</i></font>
<a name="line-21"></a><font color=Blue><i>-- certain length. We use the result by [Matsumoto and Amano 2008,</i></font>
<a name="line-22"></a><font color=Blue><i>-- &lt;<a href="http://arxiv.org/abs/0806.3834v1">http://arxiv.org/abs/0806.3834v1</a>&gt;] (rather than the older Fowler</i></font>
<a name="line-23"></a><font color=Blue><i>-- method) to avoid duplicate enumeration. By Matsumoto and Amano's</i></font>
<a name="line-24"></a><font color=Blue><i>-- result, each operator can be uniquely written in the form</i></font>
<a name="line-25"></a><font color=Blue><i>--</i></font>
<a name="line-26"></a><font color=Blue><i>-- &gt; BTATATA...TATC,</i></font>
<a name="line-27"></a><font color=Blue><i>--</i></font>
<a name="line-28"></a><font color=Blue><i>-- where:</i></font>
<a name="line-29"></a><font color=Blue><i>--</i></font>
<a name="line-30"></a><font color=Blue><i>-- * /A/ is /H/ or /SH/,</i></font>
<a name="line-31"></a><font color=Blue><i>--</i></font>
<a name="line-32"></a><font color=Blue><i>-- * /B/ is /I/ or /H/ or /SH/,</i></font>
<a name="line-33"></a><font color=Blue><i>--</i></font>
<a name="line-34"></a><font color=Blue><i>-- * /C/ is any Clifford gate, or more precisely: /C = BDEF/,</i></font>
<a name="line-35"></a><font color=Blue><i>--</i></font>
<a name="line-36"></a><font color=Blue><i>-- * /D/ is /I/ or /X/,</i></font>
<a name="line-37"></a><font color=Blue><i>--</i></font>
<a name="line-38"></a><font color=Blue><i>-- * /E/ is /I/ or /S/ or /S/[sup 2] or /S/[sup 3], and</i></font>
<a name="line-39"></a><font color=Blue><i>--</i></font>
<a name="line-40"></a><font color=Blue><i>-- * /F/ is a global phase in {1, /z/, /z/[sup 2], /z/[sup 3], /z/[sup 4], /z/[sup 5],</i></font>
<a name="line-41"></a><font color=Blue><i>-- /z/[sup 6], /z/[sup 7]}, where /z/ = [exp /i/&#960;\/4].</i></font>
<a name="line-42"></a><font color=Blue><i>--</i></font>
<a name="line-43"></a><font color=Blue><i>-- Since a global phase doesn't matter, we only need to consider the</i></font>
<a name="line-44"></a><font color=Blue><i>-- 24 Clifford gates of the form /BDE/, and this way each operator has</i></font>
<a name="line-45"></a><font color=Blue><i>-- a unique representation up to global phase.</i></font>
<a name="line-46"></a>
<a name="line-47"></a><font color=Blue><i>-- * Scalars</i></font>
<a name="line-48"></a>
<a name="line-49"></a><a name="Complexnumber"></a><font color=Blue><i>-- | A type to represent complex numbers.</i></font>
<a name="line-50"></a><a name="Complexnumber"></a><font color=Green><u>type</u></font> Complexnumber <font color=Red>=</font> Complex Double
<a name="line-51"></a>
<a name="line-52"></a><a name="Realnumber"></a><font color=Blue><i>-- | A type to represent real numbers.</i></font>
<a name="line-53"></a><a name="Realnumber"></a><font color=Green><u>type</u></font> Realnumber <font color=Red>=</font> Double
<a name="line-54"></a>
<a name="line-55"></a><a name="i"></a><font color=Blue><i>-- | The imaginary unit.</i></font>
<a name="line-56"></a><font color=Blue>i</font> <font color=Red>::</font> Complexnumber
<a name="line-57"></a><font color=Blue>i</font> <font color=Red>=</font> <font color=Magenta>0</font> <font color=Red><b>:+</b></font> <font color=Magenta>1</font>
<a name="line-58"></a>
<a name="line-59"></a><a name="s"></a><font color=Blue><i>-- | The square root of 2.</i></font>
<a name="line-60"></a><font color=Blue>s</font> <font color=Red>::</font> Complexnumber
<a name="line-61"></a><font color=Blue>s</font> <font color=Red>=</font> <font color=Magenta>1</font> <font color=Cyan>/</font> sqrt <font color=Magenta>2</font>
<a name="line-62"></a>
<a name="line-63"></a><a name="sqrti"></a><font color=Blue><i>-- | The square root of i.</i></font>
<a name="line-64"></a><font color=Blue>sqrti</font> <font color=Red>::</font> Complexnumber
<a name="line-65"></a><font color=Blue>sqrti</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>1</font> <font color=Red><b>:+</b></font> <font color=Magenta>1</font><font color=Cyan>)</font> <font color=Cyan>/</font> sqrt <font color=Magenta>2</font>
<a name="line-66"></a>
<a name="line-67"></a><font color=Blue><i>-- * Basic matrix operations</i></font>
<a name="line-68"></a>
<a name="line-69"></a><a name="Matrix"></a><font color=Blue><i>-- | The type of 2&#215;2-matrices of complex numbers. The elements are</i></font>
<a name="line-70"></a><a name="Matrix"></a><font color=Blue><i>-- listed by rows.</i></font>
<a name="line-71"></a><a name="Matrix"></a><font color=Green><u>type</u></font> Matrix <font color=Red>=</font> <font color=Cyan>(</font>Complexnumber<font color=Cyan>,</font> Complexnumber<font color=Cyan>,</font> Complexnumber<font color=Cyan>,</font> Complexnumber<font color=Cyan>)</font>
<a name="line-72"></a>
<a name="line-73"></a><a name="mult"></a><font color=Blue><i>-- | Multiply two matrices.</i></font>
<a name="line-74"></a><font color=Blue>mult</font> <font color=Red>::</font> Matrix <font color=Red>-&gt;</font> Matrix <font color=Red>-&gt;</font> Matrix
<a name="line-75"></a><font color=Blue>mult</font> <font color=Cyan>(</font>a00<font color=Cyan>,</font> a01<font color=Cyan>,</font> a10<font color=Cyan>,</font> a11<font color=Cyan>)</font> <font color=Cyan>(</font>b00<font color=Cyan>,</font> b01<font color=Cyan>,</font> b10<font color=Cyan>,</font> b11<font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-76"></a>  <font color=Cyan>(</font>c00<font color=Cyan>,</font> c01<font color=Cyan>,</font> c10<font color=Cyan>,</font> c11<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-77"></a>    <font color=Cyan>!</font>c00 <font color=Red>=</font> a00 <font color=Cyan>*</font> b00 <font color=Cyan>+</font> a01 <font color=Cyan>*</font> b10
<a name="line-78"></a>    <font color=Cyan>!</font>c01 <font color=Red>=</font> a00 <font color=Cyan>*</font> b01 <font color=Cyan>+</font> a01 <font color=Cyan>*</font> b11
<a name="line-79"></a>    <font color=Cyan>!</font>c10 <font color=Red>=</font> a10 <font color=Cyan>*</font> b00 <font color=Cyan>+</font> a11 <font color=Cyan>*</font> b10
<a name="line-80"></a>    <font color=Cyan>!</font>c11 <font color=Red>=</font> a10 <font color=Cyan>*</font> b01 <font color=Cyan>+</font> a11 <font color=Cyan>*</font> b11
<a name="line-81"></a>
<a name="line-82"></a><a name="adjoint"></a><font color=Blue><i>-- | Take the adjoint of a matrix.</i></font>
<a name="line-83"></a><font color=Blue>adjoint</font> <font color=Red>::</font> Matrix <font color=Red>-&gt;</font> Matrix
<a name="line-84"></a><font color=Blue>adjoint</font> <font color=Cyan>(</font>a00<font color=Cyan>,</font> a01<font color=Cyan>,</font> a10<font color=Cyan>,</font> a11<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>c00<font color=Cyan>,</font> c01<font color=Cyan>,</font> c10<font color=Cyan>,</font> c11<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-85"></a>  c00 <font color=Red>=</font> conjugate a00
<a name="line-86"></a>  c01 <font color=Red>=</font> conjugate a10
<a name="line-87"></a>  c10 <font color=Red>=</font> conjugate a01
<a name="line-88"></a>  c11 <font color=Red>=</font> conjugate a11
<a name="line-89"></a>
<a name="line-90"></a><a name="trace"></a><font color=Blue><i>-- | Take the trace of a matrix.</i></font>
<a name="line-91"></a><font color=Blue>trace</font> <font color=Red>::</font> Matrix <font color=Red>-&gt;</font> Complexnumber
<a name="line-92"></a><font color=Blue>trace</font> <font color=Cyan>(</font>a00<font color=Cyan>,</font> a01<font color=Cyan>,</font> a10<font color=Cyan>,</font> a11<font color=Cyan>)</font> <font color=Red>=</font> a00 <font color=Cyan>+</font> a11
<a name="line-93"></a>
<a name="line-94"></a><font color=Blue><i>-- * Specific matrices</i></font>
<a name="line-95"></a>
<a name="line-96"></a><a name="identity"></a><font color=Blue><i>-- | The identity matrix.</i></font>
<a name="line-97"></a><font color=Blue>identity</font> <font color=Red>::</font> Matrix
<a name="line-98"></a><font color=Blue>identity</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>,</font> <font color=Magenta>0</font><font color=Cyan>,</font> <font color=Magenta>0</font><font color=Cyan>,</font> <font color=Magenta>1</font><font color=Cyan>)</font>
<a name="line-99"></a>
<a name="line-100"></a><a name="not_gate"></a><font color=Blue><i>-- | The Pauli /X/ operator (not-gate).</i></font>
<a name="line-101"></a><font color=Blue>not_gate</font> <font color=Red>::</font> Matrix
<a name="line-102"></a><font color=Blue>not_gate</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>0</font><font color=Cyan>,</font> <font color=Magenta>1</font><font color=Cyan>,</font> <font color=Magenta>1</font><font color=Cyan>,</font> <font color=Magenta>0</font><font color=Cyan>)</font>
<a name="line-103"></a>
<a name="line-104"></a><a name="hadamard"></a><font color=Blue><i>-- | The Hadamard gate /H/.</i></font>
<a name="line-105"></a><font color=Blue>hadamard</font> <font color=Red>::</font> Matrix
<a name="line-106"></a><font color=Blue>hadamard</font> <font color=Red>=</font> <font color=Cyan>(</font>s<font color=Cyan>,</font> s<font color=Cyan>,</font> s<font color=Cyan>,</font> <font color=Blue><i>-</i></font>s<font color=Cyan>)</font> 
<a name="line-107"></a>
<a name="line-108"></a><a name="s_gate"></a><font color=Blue><i>-- | The Phase gate /S/.</i></font>
<a name="line-109"></a><font color=Blue>s_gate</font> <font color=Red>::</font> Matrix
<a name="line-110"></a><font color=Blue>s_gate</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>,</font> <font color=Magenta>0</font><font color=Cyan>,</font> <font color=Magenta>0</font><font color=Cyan>,</font> i<font color=Cyan>)</font> 
<a name="line-111"></a>    
<a name="line-112"></a><a name="t_gate"></a><font color=Blue><i>-- | The /T/-gate.    </i></font>
<a name="line-113"></a><font color=Blue>t_gate</font> <font color=Red>::</font> Matrix
<a name="line-114"></a><font color=Blue>t_gate</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>,</font> <font color=Magenta>0</font><font color=Cyan>,</font> <font color=Magenta>0</font><font color=Cyan>,</font> sqrti<font color=Cyan>)</font> 
<a name="line-115"></a>
<a name="line-116"></a><a name="s_mult"></a><font color=Blue><i>-- | Faster version of @mult s_gate@.</i></font>
<a name="line-117"></a><font color=Blue>s_mult</font> <font color=Red>::</font> Matrix <font color=Red>-&gt;</font> Matrix
<a name="line-118"></a><font color=Blue>s_mult</font> <font color=Cyan>(</font>b00<font color=Cyan>,</font> b01<font color=Cyan>,</font> b10 <font color=Red><b>:+</b></font> b10i<font color=Cyan>,</font> b11 <font color=Red><b>:+</b></font> b11i<font color=Cyan>)</font> <font color=Red>=</font> 
<a name="line-119"></a>  <font color=Cyan>(</font>b00<font color=Cyan>,</font> b01<font color=Cyan>,</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font>b10i<font color=Cyan>)</font> <font color=Red><b>:+</b></font> b10<font color=Cyan>,</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font>b11i<font color=Cyan>)</font> <font color=Red><b>:+</b></font> b11<font color=Cyan>)</font>
<a name="line-120"></a>
<a name="line-121"></a><a name="t_mult"></a><font color=Blue><i>-- | Faster version of @mult t_gate@.</i></font>
<a name="line-122"></a><font color=Blue>t_mult</font> <font color=Red>::</font> Matrix <font color=Red>-&gt;</font> Matrix
<a name="line-123"></a><font color=Blue>t_mult</font> <font color=Cyan>(</font>b00<font color=Cyan>,</font> b01<font color=Cyan>,</font> b10<font color=Cyan>,</font> b11<font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-124"></a>  <font color=Cyan>(</font>b00<font color=Cyan>,</font> b01<font color=Cyan>,</font> sqrti <font color=Cyan>*</font> b10<font color=Cyan>,</font> sqrti <font color=Cyan>*</font> b11<font color=Cyan>)</font> 
<a name="line-125"></a>    
<a name="line-126"></a><font color=Blue><i>-- * Norms and distance</i></font>
<a name="line-127"></a>
<a name="line-128"></a><a name="magnitude_squared"></a><font color=Blue><i>-- | Calculate the square of the magnitude of a complex number.</i></font>
<a name="line-129"></a><font color=Blue>magnitude_squared</font> <font color=Red>::</font> Complexnumber <font color=Red>-&gt;</font> Realnumber
<a name="line-130"></a><font color=Blue>magnitude_squared</font> <font color=Cyan>(</font>a <font color=Red><b>:+</b></font> b<font color=Cyan>)</font> <font color=Red>=</font> a<font color=Cyan>*</font>a <font color=Cyan>+</font> b<font color=Cyan>*</font>b
<a name="line-131"></a>
<a name="line-132"></a><a name="fowler_norm"></a><font color=Blue><i>-- | Calculate the Fowler-norm of a unitary matrix /A/, defined as</i></font>
<a name="line-133"></a><font color=Blue><i>-- </i></font>
<a name="line-134"></a><font color=Blue><i>-- &gt; norm(A) = sqrt(1 - |tr A| / n),</i></font>
<a name="line-135"></a><font color=Blue><i>-- </i></font>
<a name="line-136"></a><font color=Blue><i>-- where /n/ is the dimension.  Note: this norm is with respect to the</i></font>
<a name="line-137"></a><font color=Blue><i>-- group structure, i.e., it satisfies norm(/I/) = 0, and the triangle</i></font>
<a name="line-138"></a><font color=Blue><i>-- inequality norm(/AB/) &#8804; norm(/A/) + norm(/B/), and norm(/A/&#8315;&#185;) =</i></font>
<a name="line-139"></a><font color=Blue><i>-- norm(/A/). It is invariant under global phase, i.e.,</i></font>
<a name="line-140"></a><font color=Blue><i>-- norm(/A/)=norm(/kA/) if /k/ is a complex unit. It is also invariant</i></font>
<a name="line-141"></a><font color=Blue><i>-- under basis change.</i></font>
<a name="line-142"></a><font color=Blue><i>-- </i></font>
<a name="line-143"></a><font color=Blue><i>-- In case /n/=2, the Fowler norm is actually the same as the operator</i></font>
<a name="line-144"></a><font color=Blue><i>-- norm (up to a factor of &#8730;2), although this is not mentioned in</i></font>
<a name="line-145"></a><font color=Blue><i>-- Fowler's paper. More precisely, recall that the operator norm of a</i></font>
<a name="line-146"></a><font color=Blue><i>-- diagonalizable matrix /A/ is given by the magnitude of the largest</i></font>
<a name="line-147"></a><font color=Blue><i>-- eigenvalue. For a matrix /A/ and phase /k/, consider the operator</i></font>
<a name="line-148"></a><font color=Blue><i>-- norm of /kA-I/, and minimize this over all possible /k/. The</i></font>
<a name="line-149"></a><font color=Blue><i>-- result, for diagonalizable /A/, is:</i></font>
<a name="line-150"></a><font color=Blue><i>-- </i></font>
<a name="line-151"></a><font color=Blue><i>-- &gt; min {operator-norm(kA-I) | |k|=1} = sqrt(2 - |tr A|),</i></font>
<a name="line-152"></a><font color=Blue><i>-- </i></font>
<a name="line-153"></a><font color=Blue><i>-- which is exactly the same as the Fowler norm multiplied by &#8730;2.</i></font>
<a name="line-154"></a><font color=Blue><i>-- This is important because presumably the \"relevant\" notion of</i></font>
<a name="line-155"></a><font color=Blue><i>-- distance in quantum computing is distance in the operator norm up</i></font>
<a name="line-156"></a><font color=Blue><i>-- to a global phase.</i></font>
<a name="line-157"></a><font color=Blue>fowler_norm</font> <font color=Red>::</font> Matrix <font color=Red>-&gt;</font> Realnumber
<a name="line-158"></a><font color=Blue>fowler_norm</font> a <font color=Red>=</font> sqrt<font color=Cyan>(</font><font color=Magenta>1</font> <font color=Blue><i>-</i></font> sqrt<font color=Cyan>(</font>t<font color=Cyan>)</font><font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-159"></a>  t <font color=Red>=</font> magnitude_squared<font color=Cyan>(</font>trace<font color=Cyan>(</font>a<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-160"></a>
<a name="line-161"></a><a name="fowler_metric"></a><font color=Blue><i>-- | Note that minimizing the Fowler-norm is the same as minimizing</i></font>
<a name="line-162"></a><font color=Blue><i>-- &#8722;|tr /A/|[sup 2]; the latter requires two fewer square roots to be</i></font>
<a name="line-163"></a><font color=Blue><i>-- computed. Therefore, we provide this function for efficiency</i></font>
<a name="line-164"></a><font color=Blue><i>-- reasons.</i></font>
<a name="line-165"></a><font color=Blue>fowler_metric</font> <font color=Red>::</font> Matrix <font color=Red>-&gt;</font> Realnumber
<a name="line-166"></a><font color=Blue>fowler_metric</font> a <font color=Red>=</font> <font color=Blue><i>-</i></font>magnitude_squared<font color=Cyan>(</font>trace<font color=Cyan>(</font>a<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-167"></a>
<a name="line-168"></a><a name="fowler_norm_of_metric"></a><font color=Blue><i>-- | Convert the Fowler metric to the Fowler norm.</i></font>
<a name="line-169"></a><font color=Blue>fowler_norm_of_metric</font> <font color=Red>::</font> Realnumber <font color=Red>-&gt;</font> Realnumber
<a name="line-170"></a><font color=Blue>fowler_norm_of_metric</font> t <font color=Red>=</font> sqrt<font color=Cyan>(</font><font color=Magenta>1</font> <font color=Blue><i>-</i></font> sqrt<font color=Cyan>(</font><font color=Blue><i>-</i></font>t<font color=Cyan>)</font><font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font>
<a name="line-171"></a>
<a name="line-172"></a><a name="euclid_norm"></a><font color=Blue><i>-- | Calculate the Euclidean norm of a 2&#215;2 unitary matrix /A/, modulo</i></font>
<a name="line-173"></a><font color=Blue><i>-- global phase, defined to be the minimum of |/A/&#8722;/kI/|, where /k/ is a</i></font>
<a name="line-174"></a><font color=Blue><i>-- unit scalar. It can be defined by:</i></font>
<a name="line-175"></a><font color=Blue><i>-- </i></font>
<a name="line-176"></a><font color=Blue><i>-- &gt; norm(A) = sqrt(2 + tr AA[sup +] - 2 |tr A|)</i></font>
<a name="line-177"></a><font color=Blue><i>-- </i></font>
<a name="line-178"></a><font color=Blue><i>-- Note: this norm is with respect to the group</i></font>
<a name="line-179"></a><font color=Blue><i>-- structure, i.e., it satisfies norm(/I/) = 0, and the triangle</i></font>
<a name="line-180"></a><font color=Blue><i>-- inequality norm(/AB/) &#8804; norm(/A/) + norm(/B/), and norm(/A/&#8315;&#185;) =</i></font>
<a name="line-181"></a><font color=Blue><i>-- norm(/A/). It is invariant under global phase, i.e.,</i></font>
<a name="line-182"></a><font color=Blue><i>-- norm(/A/)=norm(/kA/) if /k/ is a complex unit. It is also invariant</i></font>
<a name="line-183"></a><font color=Blue><i>-- under basis change.</i></font>
<a name="line-184"></a><font color=Blue>euclid_norm</font> <font color=Red>::</font> Matrix <font color=Red>-&gt;</font> Realnumber
<a name="line-185"></a><font color=Blue>euclid_norm</font> a <font color=Red>=</font> sqrt<font color=Cyan>(</font><font color=Magenta>2</font> <font color=Cyan>+</font> n <font color=Blue><i>-</i></font> <font color=Magenta>2</font><font color=Cyan>*</font>t<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-186"></a>  n <font color=Red>=</font> realPart<font color=Cyan>(</font>trace<font color=Cyan>(</font>mult a <font color=Cyan>(</font>adjoint a<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-187"></a>  t <font color=Red>=</font> magnitude<font color=Cyan>(</font>trace a<font color=Cyan>)</font>
<a name="line-188"></a>  
<a name="line-189"></a><font color=Blue><i>{- minimize: F = (x-x0)^2 + (y-y0)^2 + (x-x1)^2 + (y-y1)^2, subject to
<a name="line-190"></a>   x^2 + y^2 = 1.
<a name="line-191"></a>
<a name="line-192"></a>   dF/dx = 2(x-x0) + 2(x-x1) = 4x - 2(x0+x1) 
<a name="line-193"></a>   dF/dy = 2(y-y0) + 2(y-y1) = 4y - 2(y0+y1)
<a name="line-194"></a>   solve: (dF/dx, dF/dy) || (x, y)
<a name="line-195"></a>   This happens when: (x0+x1, y0+y1) || (x,y)
<a name="line-196"></a>   I.e.: (x,y) = (x0+x1, y0+y1) / ||(x0+x1, y0+y1)||
<a name="line-197"></a>   x = (x0+x1) / sqrt ( (x0+x1)^2 + (y0+y1)^2 )
<a name="line-198"></a>   y = (y0+y1) / sqrt ( (x0+x1)^2 + (y0+y1)^2 )
<a name="line-199"></a>
<a name="line-200"></a>   In this case, F = (x-x0)^2 + (y-y0)^2 + (x-x1)^2 + (y-y1)^2
<a name="line-201"></a>   = 2x^2 - 2x(x0+x1) +x0^2 + x1^2 + .....
<a name="line-202"></a>   = 2(x0+x1)^2 / (x0+x1)^2 + (y0+y1)^2 ) 
<a name="line-203"></a>     - 2x(x0+x1) + x0^2 + x1^2
<a name="line-204"></a>   + 2(y0+y1)^2 / (x0+x1)^2 + (y0+y1)^2 )
<a name="line-205"></a>     - 2y(y0+y1) + y0^2 + y1^2  
<a name="line-206"></a>   = 2 - 2x(x0+x1) - 2y(y0+y1) + x0^2 + x1^2 + y0^2 + y1^2
<a name="line-207"></a>   = 2 - 2 (x0+x1)^2 / sqrt ( (x0+x1)^2 + (y0+y1)^2 )
<a name="line-208"></a>       - 2 (y0+y1)^2 / sqrt ( (x0+x1)^2 + (y0+y1)^2 )
<a name="line-209"></a>     + x0^2 + x1^2 + y0^2 + y1^2
<a name="line-210"></a>   = 2 - 2 ((x0+x1)^2 + (y0+y1)^2 ) / sqrt (...) 
<a name="line-211"></a>     + x0^2 + x1^2 + y0^2 + y1^2 
<a name="line-212"></a>   = 2 - 2 sqrt((x0+x1)^2 + (y0+y1)^2 ) + x0^2 + x1^2 + y0^2 + y1^2 
<a name="line-213"></a>-}</i></font>
<a name="line-214"></a>
<a name="line-215"></a><a name="dist_of_norm"></a><font color=Blue><i>-- | Turn a norm into a distance function, defined by</i></font>
<a name="line-216"></a><font color=Blue><i>-- </i></font>
<a name="line-217"></a><font color=Blue><i>-- &gt; dist(A,B) = norm(A B[sup +])</i></font>
<a name="line-218"></a><font color=Blue>dist_of_norm</font> <font color=Red>::</font> <font color=Cyan>(</font>Matrix <font color=Red>-&gt;</font> Realnumber<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>Matrix <font color=Red>-&gt;</font> Matrix <font color=Red>-&gt;</font> Realnumber<font color=Cyan>)</font>
<a name="line-219"></a><font color=Blue>dist_of_norm</font> norm a b <font color=Red>=</font>
<a name="line-220"></a>  norm <font color=Cyan>(</font>mult a <font color=Cyan>(</font>adjoint b<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-221"></a>
<a name="line-222"></a><a name="fowler_dist"></a><font color=Blue><i>-- | Calculate the Fowler distance.</i></font>
<a name="line-223"></a><font color=Blue>fowler_dist</font> <font color=Red>::</font> Matrix <font color=Red>-&gt;</font> Matrix <font color=Red>-&gt;</font> Realnumber
<a name="line-224"></a><font color=Blue>fowler_dist</font> <font color=Red>=</font> dist_of_norm fowler_norm
<a name="line-225"></a>
<a name="line-226"></a><a name="euclid_dist"></a><font color=Blue><i>-- | Calculate the Euclidean distance.</i></font>
<a name="line-227"></a><font color=Blue>euclid_dist</font> <font color=Red>::</font> Matrix <font color=Red>-&gt;</font> Matrix <font color=Red>-&gt;</font> Realnumber
<a name="line-228"></a><font color=Blue>euclid_dist</font> <font color=Red>=</font> dist_of_norm euclid_norm
<a name="line-229"></a>
<a name="line-230"></a><font color=Blue><i>-- * Representation of {/X/, /H/, /S/, /T/} circuits</i></font>
<a name="line-231"></a>
<a name="line-232"></a><a name="Gate"></a><font color=Blue><i>-- | A type to represent symbolic basis gates (X, H, S, T).</i></font>
<a name="line-233"></a><a name="Gate"></a><font color=Green><u>data</u></font> Gate <font color=Red>=</font> X <font color=Red>|</font> H <font color=Red>|</font> S <font color=Red>|</font> T 
<a name="line-234"></a>          <font color=Green><u>deriving</u></font> Show
<a name="line-235"></a>
<a name="line-236"></a><font color=Blue><i>-- * Representation of normal forms</i></font>
<a name="line-237"></a>
<a name="line-238"></a><a name="Axis"></a><font color=Blue><i>-- | An axis: /I/, /H/, or /SH/. </i></font>
<a name="line-239"></a><a name="Axis"></a><font color=Green><u>data</u></font> Axis <font color=Red>=</font> R_I <font color=Red>|</font> R_H <font color=Red>|</font> R_SH
<a name="line-240"></a>
<a name="line-241"></a><a name="Flip"></a><font color=Blue><i>-- | A flip: /I/ or /X/.</i></font>
<a name="line-242"></a><a name="Flip"></a><font color=Green><u>data</u></font> Flip <font color=Red>=</font> F_I <font color=Red>|</font> F_X
<a name="line-243"></a>
<a name="line-244"></a><a name="Turn"></a><font color=Blue><i>-- | A turn: /I/, /S/, /SS/, /SSS/.</i></font>
<a name="line-245"></a><a name="Turn"></a><font color=Green><u>data</u></font> Turn <font color=Red>=</font> T_I <font color=Red>|</font> T_S <font color=Red>|</font> T_SS <font color=Red>|</font> T_SSS
<a name="line-246"></a>
<a name="line-247"></a><a name="Clifford"></a><font color=Blue><i>-- | Each of the 24 Clifford gates (modulo global phase) can be</i></font>
<a name="line-248"></a><a name="Clifford"></a><font color=Blue><i>-- uniquely specified as a turn followed by a flip and an axis. </i></font>
<a name="line-249"></a><a name="Clifford"></a><font color=Green><u>type</u></font> Clifford <font color=Red>=</font> <font color=Cyan>(</font>Axis<font color=Cyan>,</font> Flip<font color=Cyan>,</font> Turn<font color=Cyan>)</font>
<a name="line-250"></a>
<a name="line-251"></a><a name="clifford_id"></a><font color=Blue><i>-- | The identity Clifford gate.</i></font>
<a name="line-252"></a><font color=Blue>clifford_id</font> <font color=Red>::</font> Clifford
<a name="line-253"></a><font color=Blue>clifford_id</font> <font color=Red>=</font> <font color=Cyan>(</font>R_I<font color=Cyan>,</font> F_I<font color=Cyan>,</font> T_I<font color=Cyan>)</font>
<a name="line-254"></a>
<a name="line-255"></a><a name="CAxis"></a><font color=Blue><i>-- | An axis change: /H/ or /SH/.</i></font>
<a name="line-256"></a><a name="CAxis"></a><font color=Green><u>data</u></font> CAxis <font color=Red>=</font> N_H <font color=Red>|</font> N_SH
<a name="line-257"></a>
<a name="line-258"></a><a name="CliffordT"></a><font color=Blue><i>-- | An element of the Clifford + /T/ group whose normal form does not</i></font>
<a name="line-259"></a><a name="CliffordT"></a><font color=Blue><i>-- end in /T/. It consists of a clifford circuit, followed by 0 or more</i></font>
<a name="line-260"></a><a name="CliffordT"></a><font color=Blue><i>-- gates of the form /HT/ or /SHT/.</i></font>
<a name="line-261"></a><a name="CliffordT"></a><font color=Green><u>data</u></font> CliffordT <font color=Red>=</font> Clifford Clifford <font color=Red>|</font> AppT CAxis CliffordT
<a name="line-262"></a>
<a name="line-263"></a><a name="NormalForm"></a><font color=Blue><i>-- | An element of the Clifford + /T/ group in normal form. This</i></font>
<a name="line-264"></a><a name="NormalForm"></a><font color=Blue><i>-- consists of a 'CliffordT', followed by an optional /T/.</i></font>
<a name="line-265"></a><a name="NormalForm"></a><font color=Green><u>data</u></font> NormalForm <font color=Red>=</font> NF_T CliffordT <font color=Red>|</font> NF CliffordT
<a name="line-266"></a>
<a name="line-267"></a><a name="Gatelist"></a><font color=Blue><i>-- | Class of things that can be converted to a gate list.</i></font>
<a name="line-268"></a><a name="Gatelist"></a><font color=Green><u>class</u></font> Gatelist a <font color=Green><u>where</u></font>
<a name="line-269"></a>  to_gates <font color=Red>::</font> a <font color=Red>-&gt;</font> <font color=Red>[</font>Gate<font color=Red>]</font>
<a name="line-270"></a>
<a name="line-271"></a><font color=Green><u>instance</u></font> Gatelist Axis <font color=Green><u>where</u></font>
<a name="line-272"></a>  to_gates R_I <font color=Red>=</font> []
<a name="line-273"></a>  to_gates R_H <font color=Red>=</font> <font color=Red>[</font>H<font color=Red>]</font>
<a name="line-274"></a>  to_gates R_SH <font color=Red>=</font> <font color=Red>[</font>S<font color=Cyan>,</font> H<font color=Red>]</font>
<a name="line-275"></a>  
<a name="line-276"></a><font color=Green><u>instance</u></font> Gatelist Flip <font color=Green><u>where</u></font>
<a name="line-277"></a>  to_gates F_I <font color=Red>=</font> []
<a name="line-278"></a>  to_gates F_X <font color=Red>=</font> <font color=Red>[</font>X<font color=Red>]</font>
<a name="line-279"></a>
<a name="line-280"></a><font color=Green><u>instance</u></font> Gatelist Turn <font color=Green><u>where</u></font>
<a name="line-281"></a>  to_gates T_I <font color=Red>=</font> []
<a name="line-282"></a>  to_gates T_S <font color=Red>=</font> <font color=Red>[</font>S<font color=Red>]</font>
<a name="line-283"></a>  to_gates T_SS <font color=Red>=</font> <font color=Red>[</font>S<font color=Cyan>,</font> S<font color=Red>]</font>
<a name="line-284"></a>  to_gates T_SSS <font color=Red>=</font> <font color=Red>[</font>S<font color=Cyan>,</font> S<font color=Cyan>,</font> S<font color=Red>]</font>
<a name="line-285"></a>  
<a name="line-286"></a><font color=Green><u>instance</u></font> Gatelist CAxis <font color=Green><u>where</u></font>
<a name="line-287"></a>  to_gates N_H <font color=Red>=</font> <font color=Red>[</font>H<font color=Red>]</font>
<a name="line-288"></a>  to_gates N_SH <font color=Red>=</font> <font color=Red>[</font>S<font color=Cyan>,</font> H<font color=Red>]</font>
<a name="line-289"></a>
<a name="line-290"></a><font color=Green><u>instance</u></font> Gatelist CliffordT <font color=Green><u>where</u></font>
<a name="line-291"></a>  to_gates <font color=Cyan>(</font>Clifford <font color=Cyan>(</font>x<font color=Cyan>,</font>y<font color=Cyan>,</font>z<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=</font> to_gates x <font color=Cyan>++</font> to_gates y <font color=Cyan>++</font> to_gates z
<a name="line-292"></a>  to_gates <font color=Cyan>(</font>AppT x y<font color=Cyan>)</font> <font color=Red>=</font> to_gates x <font color=Cyan>++</font> <font color=Cyan>(</font>T <font color=Red><b>:</b></font> to_gates y<font color=Cyan>)</font>
<a name="line-293"></a>  
<a name="line-294"></a><font color=Green><u>instance</u></font> Gatelist NormalForm <font color=Green><u>where</u></font>
<a name="line-295"></a>  to_gates <font color=Cyan>(</font>NF_T x<font color=Cyan>)</font> <font color=Red>=</font> T <font color=Red><b>:</b></font> to_gates x
<a name="line-296"></a>  to_gates <font color=Cyan>(</font>NF x<font color=Cyan>)</font> <font color=Red>=</font> to_gates x
<a name="line-297"></a>
<a name="line-298"></a><font color=Green><u>instance</u></font> Gatelist Gate <font color=Green><u>where</u></font>
<a name="line-299"></a>  to_gates x <font color=Red>=</font> <font color=Red>[</font>x<font color=Red>]</font>
<a name="line-300"></a>
<a name="line-301"></a><font color=Green><u>instance</u></font> Show NormalForm <font color=Green><u>where</u></font>
<a name="line-302"></a>  show x <font color=Red>=</font> concat <font color=Cyan>$</font> map show <font color=Cyan>(</font>to_gates x<font color=Cyan>)</font>
<a name="line-303"></a>  
<a name="line-304"></a><a name="nf_len"></a><font color=Blue><i>-- | Compute the length of a normal form.</i></font>
<a name="line-305"></a><font color=Blue>nf_len</font> <font color=Red>::</font> NormalForm <font color=Red>-&gt;</font> Int
<a name="line-306"></a><font color=Blue>nf_len</font> <font color=Cyan>(</font>NF_T x<font color=Cyan>)</font> <font color=Red>=</font> <font color=Magenta>1</font> <font color=Cyan>+</font> ct_len x
<a name="line-307"></a><font color=Blue>nf_len</font> <font color=Cyan>(</font>NF x<font color=Cyan>)</font> <font color=Red>=</font> ct_len x
<a name="line-308"></a>
<a name="line-309"></a><a name="ct_len"></a><font color=Blue><i>-- | Compute the length of a normal form not ending in /T/.</i></font>
<a name="line-310"></a><font color=Blue>ct_len</font> <font color=Red>::</font> CliffordT <font color=Red>-&gt;</font> Int
<a name="line-311"></a><font color=Blue>ct_len</font> <font color=Cyan>(</font>Clifford <font color=Cyan>(</font>R_I<font color=Cyan>,</font> F_I<font color=Cyan>,</font> T_I<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=</font> <font color=Magenta>0</font>
<a name="line-312"></a><font color=Blue>ct_len</font> <font color=Cyan>(</font>Clifford x<font color=Cyan>)</font> <font color=Red>=</font> <font color=Magenta>1</font>
<a name="line-313"></a><font color=Blue>ct_len</font> <font color=Cyan>(</font>AppT x y<font color=Cyan>)</font> <font color=Red>=</font> <font color=Magenta>2</font> <font color=Cyan>+</font> ct_len y
<a name="line-314"></a>
<a name="line-315"></a><font color=Blue><i>-- * Mapping circuits to unitary matrices</i></font>
<a name="line-316"></a>
<a name="line-317"></a><a name="matrix_of_gate"></a><font color=Blue><i>-- | Assign a unitary matrix to a gate.</i></font>
<a name="line-318"></a><font color=Blue>matrix_of_gate</font> <font color=Red>::</font> Gate <font color=Red>-&gt;</font> Matrix
<a name="line-319"></a><font color=Blue>matrix_of_gate</font> X <font color=Red>=</font> not_gate
<a name="line-320"></a><font color=Blue>matrix_of_gate</font> H <font color=Red>=</font> hadamard
<a name="line-321"></a><font color=Blue>matrix_of_gate</font> S <font color=Red>=</font> s_gate
<a name="line-322"></a><font color=Blue>matrix_of_gate</font> T <font color=Red>=</font> t_gate
<a name="line-323"></a>  
<a name="line-324"></a><a name="matrix_of_gatelist"></a><font color=Blue><i>-- | Assign a unitary matrix to a gate list.</i></font>
<a name="line-325"></a><font color=Blue>matrix_of_gatelist</font> <font color=Red>::</font> <font color=Red>[</font>Gate<font color=Red>]</font> <font color=Red>-&gt;</font> Matrix
<a name="line-326"></a><font color=Blue>matrix_of_gatelist</font> [] <font color=Red>=</font> identity
<a name="line-327"></a><font color=Blue>matrix_of_gatelist</font> <font color=Red>[</font>h<font color=Red>]</font> <font color=Red>=</font> matrix_of_gate h
<a name="line-328"></a><font color=Blue>matrix_of_gatelist</font> <font color=Cyan>(</font>h<font color=Red><b>:</b></font>t<font color=Cyan>)</font> <font color=Red>=</font> mult <font color=Cyan>(</font>matrix_of_gate h<font color=Cyan>)</font> <font color=Cyan>(</font>matrix_of_gatelist t<font color=Cyan>)</font>
<a name="line-329"></a>                           
<a name="line-330"></a><a name="to_matrix"></a><font color=Blue><i>-- | Convert a circuit representation to a matrix</i></font>
<a name="line-331"></a><font color=Blue>to_matrix</font> <font color=Red>::</font> Gatelist a <font color=Red>=&gt;</font> a <font color=Red>-&gt;</font> Matrix
<a name="line-332"></a><font color=Blue>to_matrix</font> <font color=Red>=</font> matrix_of_gatelist <font color=Cyan>.</font> to_gates
<a name="line-333"></a>
<a name="line-334"></a><font color=Blue><i>-- * More memory-efficient enumeration</i></font>
<a name="line-335"></a>    
<a name="line-336"></a><font color=Blue><i>-- | Uniquely enumerate all normal forms. Return an infinite list of</i></font>
<a name="line-337"></a><font color=Blue><i>-- triples (/nf/, /m/, /n/), where /nf/ is a normal form, /m/ is the</i></font>
<a name="line-338"></a><font color=Blue><i>-- product of the normal form's matrix and /m0/, and /n/ is the size</i></font>
<a name="line-339"></a><font color=Blue><i>-- of the normal form. The list is ordered by increasing /n/. We use</i></font>
<a name="line-340"></a><font color=Blue><i>-- an iterated depth-first enumeration with logarithmic memory usage.</i></font>
<a name="line-341"></a>
<a name="line-342"></a><a name="nf_matrix_gen"></a><font color=Blue>nf_matrix_gen</font> <font color=Red>::</font> Matrix <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Cyan>(</font>NormalForm<font color=Cyan>,</font> Matrix<font color=Cyan>,</font> Int<font color=Cyan>)</font><font color=Red>]</font>
<a name="line-343"></a><font color=Blue>nf_matrix_gen</font> m0 <font color=Red>=</font> aux <font color=Magenta>0</font> <font color=Green><u>where</u></font>
<a name="line-344"></a>  aux n <font color=Red>=</font> nf_length m0 n <font color=Cyan>(</font>aux <font color=Cyan>(</font>n<font color=Cyan>+</font><font color=Magenta>1</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-345"></a>  
<a name="line-346"></a><a name="nf_length"></a><font color=Blue><i>-- | Enumerate all normal forms of size /len/, followed by /tail/.</i></font>
<a name="line-347"></a><font color=Blue><i>-- This function is productive, i.e., the resulting list is lazy with</i></font>
<a name="line-348"></a><font color=Blue><i>-- no storage.</i></font>
<a name="line-349"></a><font color=Blue>nf_length</font> <font color=Red>::</font> Matrix <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Cyan>(</font>NormalForm<font color=Cyan>,</font> Matrix<font color=Cyan>,</font> Int<font color=Cyan>)</font><font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Cyan>(</font>NormalForm<font color=Cyan>,</font> Matrix<font color=Cyan>,</font> Int<font color=Cyan>)</font><font color=Red>]</font>
<a name="line-350"></a><font color=Blue>nf_length</font> m0 len tail <font color=Red>=</font>  <font color=Blue><i>-- enumerate all nf's of size n, followed by tail</i></font>
<a name="line-351"></a>  foldr enumerate_under tail base_cases
<a name="line-352"></a>  <font color=Green><u>where</u></font>
<a name="line-353"></a>    base_cases <font color=Red>=</font> map <font color=Cyan>(</font><font color=Red>\</font>x <font color=Red>-&gt;</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> to_matrix x <font color=Cyan>`mult`</font> m0<font color=Cyan>,</font> ct_len x<font color=Cyan>)</font><font color=Cyan>)</font> clifford
<a name="line-354"></a>    clifford <font color=Red>=</font> <font color=Red>[</font> Clifford <font color=Cyan>(</font>x<font color=Cyan>,</font>y<font color=Cyan>,</font>z<font color=Cyan>)</font> <font color=Red>|</font> x <font color=Red>&lt;-</font> <font color=Red>[</font> R_I<font color=Cyan>,</font> R_H<font color=Cyan>,</font> R_SH <font color=Red>]</font><font color=Cyan>,</font>
<a name="line-355"></a>                                  y <font color=Red>&lt;-</font> <font color=Red>[</font> F_I<font color=Cyan>,</font> F_X <font color=Red>]</font><font color=Cyan>,</font>
<a name="line-356"></a>                                  z <font color=Red>&lt;-</font> <font color=Red>[</font> T_I<font color=Cyan>,</font> T_S<font color=Cyan>,</font> T_SS<font color=Cyan>,</font> T_SSS <font color=Red>]</font><font color=Red>]</font>
<a name="line-357"></a>    <font color=Blue><i>-- the enumerate_under function enumerates all 'NormalForm's of</i></font>
<a name="line-358"></a>    <font color=Blue><i>-- length /len/ under the given 'CliffordT'.</i></font>
<a name="line-359"></a>    ht_gate <font color=Red>=</font> hadamard <font color=Cyan>`mult`</font> t_gate
<a name="line-360"></a>    enumerate_under <font color=Cyan>(</font>nf<font color=Cyan>,</font> m<font color=Cyan>,</font> n<font color=Cyan>)</font> tail 
<a name="line-361"></a>      <font color=Red>|</font> n<font color=Cyan>&gt;</font>len <font color=Red>=</font> tail
<a name="line-362"></a>      <font color=Red>|</font> n<font color=Cyan>==</font>len <font color=Red>=</font> <font color=Cyan>(</font>NF nf<font color=Cyan>,</font> m<font color=Cyan>,</font> n<font color=Cyan>)</font> <font color=Red><b>:</b></font> tail
<a name="line-363"></a>      <font color=Red>|</font> n<font color=Cyan>==</font>len<font color=Blue><i>-</i></font><font color=Magenta>1</font> <font color=Red>=</font> <font color=Cyan>(</font>NF_T nf<font color=Cyan>,</font> t_mult m<font color=Cyan>,</font> n<font color=Cyan>+</font><font color=Magenta>1</font><font color=Cyan>)</font> <font color=Red><b>:</b></font> tail
<a name="line-364"></a>      <font color=Red>|</font> otherwise <font color=Red>=</font> tail1
<a name="line-365"></a>        <font color=Green><u>where</u></font>
<a name="line-366"></a>          m1 <font color=Red>=</font> ht_gate <font color=Cyan>`mult`</font> m
<a name="line-367"></a>          <font color=Blue><i>--m1 = h_mult $ t_mult m</i></font>
<a name="line-368"></a>          m2 <font color=Red>=</font> s_mult m1
<a name="line-369"></a>          tail1 <font color=Red>=</font> enumerate_under <font color=Cyan>(</font>AppT N_H nf<font color=Cyan>,</font> m1<font color=Cyan>,</font> n<font color=Cyan>+</font><font color=Magenta>2</font><font color=Cyan>)</font> tail2
<a name="line-370"></a>          tail2 <font color=Red>=</font> enumerate_under <font color=Cyan>(</font>AppT N_SH nf<font color=Cyan>,</font> m2<font color=Cyan>,</font> n<font color=Cyan>+</font><font color=Magenta>2</font><font color=Cyan>)</font> tail
<a name="line-371"></a>
<a name="line-372"></a><font color=Blue><i>-- * Finding best approximations</i></font>
<a name="line-373"></a>
<a name="line-374"></a><a name="approximate"></a><font color=Blue><i>-- | Given a norm and a matrix, find the successively best</i></font>
<a name="line-375"></a><font color=Blue><i>-- approximation for each length. Return an infinite list of</i></font>
<a name="line-376"></a><font color=Blue><i>-- quadruples (/m/, /nf/, /len/, /n/, &#948;). Here /nf/ is the normal</i></font>
<a name="line-377"></a><font color=Blue><i>-- form, /m/ is its matrix, /len/ is the actual length of the normal</i></font>
<a name="line-378"></a><font color=Blue><i>-- form, /n/ is the length for which the normal form is optimal, and &#948;</i></font>
<a name="line-379"></a><font color=Blue><i>-- is the distance.</i></font>
<a name="line-380"></a><font color=Blue>approximate</font> <font color=Red>::</font> <font color=Cyan>(</font>Matrix <font color=Red>-&gt;</font> Realnumber<font color=Cyan>)</font> <font color=Red>-&gt;</font> Matrix <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Cyan>(</font>Matrix<font color=Cyan>,</font> NormalForm<font color=Cyan>,</font> Int<font color=Cyan>,</font> Int<font color=Cyan>,</font> Realnumber<font color=Cyan>)</font><font color=Red>]</font>
<a name="line-381"></a><font color=Blue>approximate</font> norm m0 <font color=Red>=</font>
<a name="line-382"></a>  aux t <font color=Cyan>(</font>m<font color=Cyan>,</font> nf<font color=Cyan>,</font> n<font color=Cyan>,</font> n<font color=Cyan>,</font> norm m<font color=Cyan>)</font>
<a name="line-383"></a>    <font color=Green><u>where</u></font> 
<a name="line-384"></a>      <font color=Cyan>(</font>nf<font color=Cyan>,</font>m<font color=Cyan>,</font>n<font color=Cyan>)</font> <font color=Red><b>:</b></font> t <font color=Red>=</font> nf_matrix_gen m0
<a name="line-385"></a>      aux <font color=Cyan>(</font><font color=Cyan>(</font>nf'<font color=Cyan>,</font>m'<font color=Cyan>,</font>n'<font color=Cyan>)</font> <font color=Red><b>:</b></font> t<font color=Cyan>)</font> <font color=Cyan>(</font>m<font color=Cyan>,</font> nf<font color=Cyan>,</font> len<font color=Cyan>,</font> n<font color=Cyan>,</font> delta<font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-386"></a>        <font color=Green><u>if</u></font> n' <font color=Cyan>&gt;</font> n <font color=Green><u>then</u></font> <font color=Cyan>(</font>m<font color=Cyan>,</font> nf<font color=Cyan>,</font> len<font color=Cyan>,</font> n<font color=Cyan>,</font> delta<font color=Cyan>)</font> <font color=Red><b>:</b></font> remainder <font color=Green><u>else</u></font> remainder
<a name="line-387"></a>          <font color=Green><u>where</u></font>
<a name="line-388"></a>            delta' <font color=Red>=</font> norm m'
<a name="line-389"></a>            remainder <font color=Red>=</font> aux t best
<a name="line-390"></a>            best <font color=Red>=</font> <font color=Green><u>if</u></font> delta' <font color=Cyan>&lt;</font> delta <font color=Green><u>then</u></font> <font color=Cyan>(</font>m'<font color=Cyan>,</font> nf'<font color=Cyan>,</font> n'<font color=Cyan>,</font> n'<font color=Cyan>,</font> delta'<font color=Cyan>)</font> <font color=Green><u>else</u></font> <font color=Cyan>(</font>m<font color=Cyan>,</font> nf<font color=Cyan>,</font> len<font color=Cyan>,</font> n'<font color=Cyan>,</font> delta<font color=Cyan>)</font>
<a name="line-391"></a>      aux [] <font color=Green><u>_</u></font> <font color=Red>=</font> undefined   <font color=Blue><i>-- not reached, because nf_matrix_gen returns an infinite list</i></font>
<a name="line-392"></a>
<a name="line-393"></a><font color=Blue><i>-- * Some gates to approximate</i></font>
<a name="line-394"></a>         
<a name="line-395"></a><a name="some_gate"></a><font color=Blue><i>-- | Some arbitrary unitary matrix for testing.         </i></font>
<a name="line-396"></a><font color=Blue>some_gate</font> <font color=Red>::</font> Matrix
<a name="line-397"></a><font color=Blue>some_gate</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>0.6</font><font color=Cyan>,</font> <font color=Magenta>0.8</font><font color=Cyan>,</font> <font color=Magenta>0.8</font><font color=Cyan>,</font> <font color=Blue><i>-</i></font><font color=Magenta>0.6</font><font color=Cyan>)</font>
<a name="line-398"></a>
<a name="line-399"></a><font color=Blue><i>-- | Return a random unitary matrix (Haar measure).</i></font>
<a name="line-400"></a>
<a name="line-401"></a><a name="random_gate"></a><font color=Blue><i>-- We approximate the Haar measure by repeating some non-uniformly</i></font>
<a name="line-402"></a><font color=Blue><i>-- distributed random unitary a large number of times. The matrix is</i></font>
<a name="line-403"></a><font color=Blue><i>-- computed of the form HRHRHRHRHR, where H is Hadamard and R is a</i></font>
<a name="line-404"></a><font color=Blue><i>-- random Z-rotation.</i></font>
<a name="line-405"></a><font color=Blue>random_gate</font> <font color=Red>::</font> IO Matrix
<a name="line-406"></a><font color=Blue>random_gate</font> <font color=Red>=</font> <font color=Green><u>do</u></font> 
<a name="line-407"></a>  list <font color=Red>&lt;-</font> sequence <font color=Cyan>(</font>take <font color=Magenta>100</font> <font color=Cyan>$</font> repeat random_Hrot<font color=Cyan>)</font>
<a name="line-408"></a>  return <font color=Cyan>(</font>foldl1' mult list<font color=Cyan>)</font>
<a name="line-409"></a>    <font color=Green><u>where</u></font>
<a name="line-410"></a>      random_Hrot <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-411"></a>        alpha <font color=Red>&lt;-</font> randomIO <font color=Red>::</font> IO Double
<a name="line-412"></a>        return <font color=Cyan>$</font> mult hadamard <font color=Cyan>(</font>zrot_gate <font color=Cyan>(</font><font color=Magenta>2</font><font color=Cyan>*</font>pi <font color=Cyan>*</font> alpha<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-413"></a>
<a name="line-414"></a><a name="zrot_gate"></a><font color=Blue><i>-- | Return a /Z/-rotation by angle alpha.    </i></font>
<a name="line-415"></a><font color=Blue>zrot_gate</font> <font color=Red>::</font> Realnumber <font color=Red>-&gt;</font> Matrix
<a name="line-416"></a><font color=Blue>zrot_gate</font> alpha <font color=Red>=</font>
<a name="line-417"></a>  <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>,</font> <font color=Magenta>0</font><font color=Cyan>,</font> <font color=Magenta>0</font><font color=Cyan>,</font> cis alpha<font color=Cyan>)</font>
<a name="line-418"></a>
<a name="line-419"></a><a name="phase_gate"></a><font color=Blue><i>-- | Return a phase rotation gate with phase [exp /i/&#960; \/ 2[sup /d/]].</i></font>
<a name="line-420"></a><font color=Blue>phase_gate</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> Matrix
<a name="line-421"></a><font color=Blue>phase_gate</font> d <font color=Red>=</font> zrot_gate alpha
<a name="line-422"></a>  <font color=Green><u>where</u></font>
<a name="line-423"></a>    alpha <font color=Red>=</font> pi <font color=Cyan>/</font> <font color=Cyan>(</font><font color=Magenta>2</font> <font color=Cyan>**</font> <font color=Cyan>(</font>fromIntegral d<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-424"></a>
<a name="line-425"></a><font color=Blue><i>-- * User interface</i></font>
<a name="line-426"></a>
<a name="line-427"></a><a name="print_list"></a><font color=Blue><i>-- | A convenience function for printing a list, one element per line.</i></font>
<a name="line-428"></a><font color=Blue>print_list</font> <font color=Red>::</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> String<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Red>[</font>a<font color=Red>]</font> <font color=Red>-&gt;</font> IO()
<a name="line-429"></a><font color=Blue>print_list</font> show_elt [] <font color=Red>=</font> return ()
<a name="line-430"></a><font color=Blue>print_list</font> show_elt <font color=Cyan>(</font>h<font color=Red><b>:</b></font>t<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-431"></a>  putStr <font color=Cyan>(</font>show_elt h<font color=Cyan>)</font>
<a name="line-432"></a>  putStr <font color=Magenta>"\n"</font>
<a name="line-433"></a>  hFlush stdout
<a name="line-434"></a>  print_list show_elt t
<a name="line-435"></a>
<a name="line-436"></a><a name="main"></a><font color=Blue><i>-- | The main function.</i></font>
<a name="line-437"></a><font color=Blue>main</font> <font color=Red>::</font> IO()
<a name="line-438"></a><font color=Blue>main</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-439"></a>    args <font color=Red>&lt;-</font> getArgs
<a name="line-440"></a>    parsed <font color=Red>&lt;-</font> parse_args args
<a name="line-441"></a>    putStrLn <font color=Cyan>$</font> show parsed
<a name="line-442"></a>    print_list show_parts <font color=Cyan>$</font> approximate fowler_metric parsed
<a name="line-443"></a>    return ()
<a name="line-444"></a>    <font color=Green><u>where</u></font>
<a name="line-445"></a>      show_parts <font color=Cyan>(</font>m<font color=Cyan>,</font> nf<font color=Cyan>,</font> len<font color=Cyan>,</font> n<font color=Cyan>,</font> delta<font color=Cyan>)</font> <font color=Red>=</font> show <font color=Cyan>(</font>n<font color=Cyan>,</font> fowler_norm_of_metric delta<font color=Cyan>,</font> len<font color=Cyan>,</font> nf<font color=Cyan>)</font>
<a name="line-446"></a>    
<a name="line-447"></a>
<a name="line-448"></a><font color=Blue><i>-- | Parse the command line arguments. Possible arguments are:</i></font>
<a name="line-449"></a><font color=Blue><i>-- </i></font>
<a name="line-450"></a><font color=Blue><i>-- * @random_gate@ - approximate a random gate.</i></font>
<a name="line-451"></a><font color=Blue><i>-- </i></font>
<a name="line-452"></a><font color=Blue><i>-- * @zrot_gate &lt;double&gt;@ - approximate a /Z/-rotation by angle alpha.  </i></font>
<a name="line-453"></a><font color=Blue><i>-- </i></font>
<a name="line-454"></a><font color=Blue><i>-- * @phase_gate &lt;int&gt;@ - approximate a /Z/-rotation gate with angle</i></font>
<a name="line-455"></a><font color=Blue><i>-- [exp /i/&#960; \/ 2[sup /d/]].</i></font>
<a name="line-456"></a>
<a name="line-457"></a><a name="parse_args"></a><font color=Blue>parse_args</font> <font color=Red>::</font> <font color=Red>[</font>String<font color=Red>]</font> <font color=Red>-&gt;</font> IO Matrix
<a name="line-458"></a><font color=Blue>parse_args</font> args <font color=Red>=</font> 
<a name="line-459"></a>    <font color=Green><u>if</u></font> <font color=Cyan>(</font>length args <font color=Cyan>&lt;</font> <font color=Magenta>1</font><font color=Cyan>)</font> 
<a name="line-460"></a>    <font color=Green><u>then</u></font> error <font color=Magenta>"No command line arguments given. Possible arguments are: random_gate, zrot_gate &lt;theta&gt;, phase_gate &lt;n&gt;"</font>
<a name="line-461"></a>    <font color=Green><u>else</u></font> <font color=Green><u>let</u></font> <font color=Cyan>(</font>gate_type<font color=Red><b>:</b></font>gate_rest<font color=Cyan>)</font> <font color=Red>=</font> args
<a name="line-462"></a>          <font color=Green><u>in</u></font> <font color=Green><u>case</u></font> <font color=Cyan>(</font>gate_type<font color=Cyan>)</font> <font color=Green><u>of</u></font>
<a name="line-463"></a>            <font color=Magenta>"random_gate"</font> <font color=Red>-&gt;</font> random_gate
<a name="line-464"></a>            <font color=Magenta>"zrot_gate"</font>   <font color=Red>-&gt;</font> return <font color=Cyan>$</font> zrot_gate  <font color=Cyan>(</font>read <font color=Cyan>(</font>gate_rest <font color=Cyan>!!</font> <font color=Magenta>0</font><font color=Cyan>)</font> <font color=Red>::</font> Double<font color=Cyan>)</font>
<a name="line-465"></a>            <font color=Magenta>"phase_gate"</font>  <font color=Red>-&gt;</font> return <font color=Cyan>$</font> phase_gate <font color=Cyan>(</font>read <font color=Cyan>(</font>gate_rest <font color=Cyan>!!</font> <font color=Magenta>0</font><font color=Cyan>)</font> <font color=Red>::</font> Int<font color=Cyan>)</font>
<a name="line-466"></a>            <font color=Green><u>_</u></font> <font color=Red>-&gt;</font> error <font color=Cyan>$</font> <font color=Magenta>"Unknown gate type "</font> <font color=Cyan>++</font> gate_type
<a name="line-467"></a>
</pre>
</body>
</html>