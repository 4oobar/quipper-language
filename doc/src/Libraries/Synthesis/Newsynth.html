<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>{-# LANGUAGE BangPatterns #-}</i></font>
<a name="line-2"></a><font color=Blue><i>{-# LANGUAGE ScopedTypeVariables #-}</i></font>
<a name="line-3"></a>
<a name="line-4"></a><font color=Blue><i>-- | This module implements an efficient single-qubit Clifford+/T/</i></font>
<a name="line-5"></a><font color=Blue><i>-- approximation algorithm. The algorithm is described here:</i></font>
<a name="line-6"></a><font color=Blue><i>-- </i></font>
<a name="line-7"></a><font color=Blue><i>-- * Peter Selinger. Efficient Clifford+/T/ approximation of</i></font>
<a name="line-8"></a><font color=Blue><i>-- single-qubit operators. &lt;<a href="http://arxiv.org/abs/1212.6253">http://arxiv.org/abs/1212.6253</a>&gt;.</i></font>
<a name="line-9"></a>
<a name="line-10"></a><font color=Green><u>module</u></font> Libraries<font color=Cyan>.</font>Synthesis<font color=Cyan>.</font>Newsynth <font color=Green><u>where</u></font>
<a name="line-11"></a>
<a name="line-12"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Synthesis<font color=Cyan>.</font>Ring
<a name="line-13"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Synthesis<font color=Cyan>.</font>Ring<font color=Cyan>.</font>FixedPrec
<a name="line-14"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Synthesis<font color=Cyan>.</font>Matrix
<a name="line-15"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Synthesis<font color=Cyan>.</font>CliffordT
<a name="line-16"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Synthesis<font color=Cyan>.</font>EuclideanDomain
<a name="line-17"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Synthesis<font color=Cyan>.</font>SymReal
<a name="line-18"></a>
<a name="line-19"></a><font color=Green><u>import</u></font> System<font color=Cyan>.</font>Random
<a name="line-20"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Maybe
<a name="line-21"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Number<font color=Cyan>.</font>FixedPrec
<a name="line-22"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Time
<a name="line-23"></a><font color=Green><u>import</u></font> System<font color=Cyan>.</font>Locale
<a name="line-24"></a><font color=Green><u>import</u></font> System<font color=Cyan>.</font>IO
<a name="line-25"></a>
<a name="line-26"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-27"></a><font color=Blue><i>-- * Miscellaneous functions</i></font>
<a name="line-28"></a>
<a name="line-29"></a><a name="ensure"></a><font color=Blue><i>-- | A useful operation for the 'Maybe' monad, used to ensure that</i></font>
<a name="line-30"></a><font color=Blue><i>-- some condition holds (i.e., return 'Nothing' if the condition is</i></font>
<a name="line-31"></a><font color=Blue><i>-- false). To be used like this:</i></font>
<a name="line-32"></a><font color=Blue><i>-- </i></font>
<a name="line-33"></a><font color=Blue><i>-- &gt; do</i></font>
<a name="line-34"></a><font color=Blue><i>-- &gt;   x &lt;- something</i></font>
<a name="line-35"></a><font color=Blue><i>-- &gt;   y &lt;- something_else</i></font>
<a name="line-36"></a><font color=Blue><i>-- &gt;   ensure (x &gt; y)</i></font>
<a name="line-37"></a><font color=Blue><i>-- &gt;   ...</i></font>
<a name="line-38"></a><font color=Blue>ensure</font> <font color=Red>::</font> Bool <font color=Red>-&gt;</font> Maybe ()
<a name="line-39"></a><font color=Blue>ensure</font> True <font color=Red>=</font> Just ()
<a name="line-40"></a><font color=Blue>ensure</font> False <font color=Red>=</font> Nothing
<a name="line-41"></a>
<a name="line-42"></a><a name="maybe_head"></a><font color=Blue><i>-- | Return the head of a list, if non-empty, or else 'Nothing'.</i></font>
<a name="line-43"></a><font color=Blue>maybe_head</font> <font color=Red>::</font> <font color=Red>[</font>a<font color=Red>]</font> <font color=Red>-&gt;</font> Maybe a
<a name="line-44"></a><font color=Blue>maybe_head</font> [] <font color=Red>=</font> Nothing
<a name="line-45"></a><font color=Blue>maybe_head</font> <font color=Cyan>(</font>h<font color=Red><b>:</b></font>t<font color=Cyan>)</font> <font color=Red>=</font> Just h
<a name="line-46"></a>
<a name="line-47"></a><a name="power"></a><font color=Blue><i>-- | Exponentiation via repeated squaring, parameterized by a</i></font>
<a name="line-48"></a><font color=Blue><i>-- multiplication function and a unit. Given an associative</i></font>
<a name="line-49"></a><font color=Blue><i>-- multiplication function @*@ with unit @e@, the function 'power'</i></font>
<a name="line-50"></a><font color=Blue><i>-- @(*)@ /e/ /a/ /n/ efficiently computes /a/[sup /n/] = /a/ @*@ (/a/</i></font>
<a name="line-51"></a><font color=Blue><i>-- @*@ (&#8230; @*@ (/a/ @*@ /e/)&#8230;)).</i></font>
<a name="line-52"></a><font color=Blue>power</font> <font color=Red>::</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> a<font color=Cyan>)</font> <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font>  a <font color=Red>-&gt;</font> Integer <font color=Red>-&gt;</font> a
<a name="line-53"></a><font color=Blue>power</font> mul unit <font color=Red>=</font> aux <font color=Green><u>where</u></font>
<a name="line-54"></a>  aux x n
<a name="line-55"></a>    <font color=Red>|</font> n <font color=Cyan>&lt;=</font> <font color=Magenta>0</font> <font color=Red>=</font> unit
<a name="line-56"></a>    <font color=Red>|</font> n <font color=Cyan>==</font> <font color=Magenta>1</font> <font color=Red>=</font> x
<a name="line-57"></a>    <font color=Red>|</font> odd n <font color=Red>=</font> x <font color=Cyan>`mul`</font> <font color=Cyan>(</font>x <font color=Cyan>`aux`</font> <font color=Cyan>(</font>n<font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-58"></a>    <font color=Red>|</font> otherwise <font color=Red>=</font> y <font color=Cyan>`mul`</font> y <font color=Green><u>where</u></font> y <font color=Red>=</font> x <font color=Cyan>`aux`</font> <font color=Cyan>(</font>n <font color=Cyan>`div`</font> <font color=Magenta>2</font><font color=Cyan>)</font>
<a name="line-59"></a>  
<a name="line-60"></a><a name="floorlog"></a><font color=Blue><i>-- | Given positive numbers /b/ and /x/, return (/n/, /r/) such that</i></font>
<a name="line-61"></a><font color=Blue><i>-- </i></font>
<a name="line-62"></a><font color=Blue><i>-- * /x/ = /r/ /b/[sup /n/] and                           </i></font>
<a name="line-63"></a><font color=Blue><i>--                                   </i></font>
<a name="line-64"></a><font color=Blue><i>-- * 1 &#8804; /r/ &lt; /b/.                                  </i></font>
<a name="line-65"></a><font color=Blue><i>--                                   </i></font>
<a name="line-66"></a><font color=Blue><i>-- In other words, let /n/ = &#8970;log[sub /b/] /x/&#8971; and </i></font>
<a name="line-67"></a><font color=Blue><i>-- /r/ = /x/ /b/[sup &#8722;/n/]. This can be more efficient than 'floor'</i></font>
<a name="line-68"></a><font color=Blue><i>-- ('logBase' /b/ /x/) depending on the type; moreover, it also works</i></font>
<a name="line-69"></a><font color=Blue><i>-- for exact types such as 'Rational' and 'EReal'.</i></font>
<a name="line-70"></a><font color=Blue>floorlog</font> <font color=Red>::</font> <font color=Cyan>(</font>Fractional b<font color=Cyan>,</font> Ord b<font color=Cyan>)</font> <font color=Red>=&gt;</font> b <font color=Red>-&gt;</font> b <font color=Red>-&gt;</font> <font color=Cyan>(</font>Integer<font color=Cyan>,</font> b<font color=Cyan>)</font>
<a name="line-71"></a><font color=Blue>floorlog</font> b x 
<a name="line-72"></a>    <font color=Red>|</font> x <font color=Cyan>&lt;=</font> <font color=Magenta>0</font>            <font color=Red>=</font> error <font color=Magenta>"floorlog: argument not positive"</font>    
<a name="line-73"></a>    <font color=Red>|</font> <font color=Magenta>1</font> <font color=Cyan>&lt;=</font> x <font color=Cyan>&amp;&amp;</font> x <font color=Cyan>&lt;</font> b   <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>0</font><font color=Cyan>,</font> x<font color=Cyan>)</font>
<a name="line-74"></a>    <font color=Red>|</font> <font color=Magenta>1</font> <font color=Cyan>&lt;=</font> x<font color=Cyan>*</font>b <font color=Cyan>&amp;&amp;</font> x <font color=Cyan>&lt;</font> <font color=Magenta>1</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>,</font> b<font color=Cyan>*</font>x<font color=Cyan>)</font>
<a name="line-75"></a>    <font color=Red>|</font> r <font color=Cyan>&lt;</font> b             <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>2</font><font color=Cyan>*</font>n<font color=Cyan>,</font> r<font color=Cyan>)</font>
<a name="line-76"></a>    <font color=Red>|</font> otherwise         <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>2</font><font color=Cyan>*</font>n<font color=Cyan>+</font><font color=Magenta>1</font><font color=Cyan>,</font> r<font color=Cyan>/</font>b<font color=Cyan>)</font>
<a name="line-77"></a>    <font color=Green><u>where</u></font>
<a name="line-78"></a>      <font color=Cyan>(</font>n<font color=Cyan>,</font> r<font color=Cyan>)</font> <font color=Red>=</font> floorlog <font color=Cyan>(</font>b<font color=Cyan>^</font><font color=Magenta>2</font><font color=Cyan>)</font> x
<a name="line-79"></a>
<a name="line-80"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-81"></a><font color=Blue><i>-- * Randomized algorithms</i></font>
<a name="line-82"></a>
<a name="line-83"></a><a name="keeptrying"></a><font color=Blue><i>-- | A combinator for turning a probabilistic function that succeeds</i></font>
<a name="line-84"></a><font color=Blue><i>-- with some small probability into a probabilistic function that</i></font>
<a name="line-85"></a><font color=Blue><i>-- always succeeds, by trying again and again.</i></font>
<a name="line-86"></a><font color=Blue>keeptrying</font> <font color=Red>::</font> <font color=Cyan>(</font>RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>g <font color=Red>-&gt;</font> Maybe a<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>g <font color=Red>-&gt;</font> a<font color=Cyan>)</font>
<a name="line-87"></a><font color=Blue>keeptrying</font> f g <font color=Red>=</font> <font color=Green><u>case</u></font> f g1 <font color=Green><u>of</u></font>
<a name="line-88"></a>  Just res <font color=Red>-&gt;</font> res
<a name="line-89"></a>  Nothing <font color=Red>-&gt;</font> keeptrying f g2
<a name="line-90"></a>  <font color=Green><u>where</u></font>
<a name="line-91"></a>    <font color=Cyan>(</font>g1<font color=Cyan>,</font> g2<font color=Cyan>)</font> <font color=Red>=</font> split g
<a name="line-92"></a>
<a name="line-93"></a><a name="keeptrying_count"></a><font color=Blue><i>-- | Like 'keeptrying', but also returns a count of the number of attempts.</i></font>
<a name="line-94"></a><font color=Blue>keeptrying_count</font> <font color=Red>::</font> <font color=Cyan>(</font>RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>g <font color=Red>-&gt;</font> Maybe a<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>g <font color=Red>-&gt;</font> <font color=Cyan>(</font>a<font color=Cyan>,</font> Integer<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-95"></a><font color=Blue>keeptrying_count</font> f g <font color=Red>=</font> aux g <font color=Magenta>1</font> <font color=Green><u>where</u></font>
<a name="line-96"></a>  aux g n <font color=Red>=</font> <font color=Green><u>case</u></font> f g1 <font color=Green><u>of</u></font>
<a name="line-97"></a>    Just res <font color=Red>-&gt;</font> <font color=Cyan>(</font>res<font color=Cyan>,</font> n<font color=Cyan>)</font>
<a name="line-98"></a>    Nothing <font color=Red>-&gt;</font> aux g2 n1
<a name="line-99"></a>    <font color=Green><u>where</u></font>
<a name="line-100"></a>      <font color=Cyan>(</font>g1<font color=Cyan>,</font> g2<font color=Cyan>)</font> <font color=Red>=</font> split g
<a name="line-101"></a>      <font color=Cyan>!</font>n1 <font color=Red>=</font> n <font color=Cyan>+</font> <font color=Magenta>1</font>
<a name="line-102"></a>
<a name="line-103"></a><a name="try_for"></a><font color=Blue><i>-- | A combinator for turning a probabilistic function that succeeds</i></font>
<a name="line-104"></a><font color=Blue><i>-- with some small probability into a probabilistic function that</i></font>
<a name="line-105"></a><font color=Blue><i>-- succeeds with a higher probability, by repeating it /n/ times. </i></font>
<a name="line-106"></a><font color=Blue>try_for</font> <font color=Red>::</font> <font color=Cyan>(</font>RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> Integer <font color=Red>-&gt;</font> <font color=Cyan>(</font>g <font color=Red>-&gt;</font> Maybe a<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>g <font color=Red>-&gt;</font> Maybe a<font color=Cyan>)</font>
<a name="line-107"></a><font color=Blue>try_for</font> n f g
<a name="line-108"></a>  <font color=Red>|</font> n <font color=Cyan>&lt;=</font> <font color=Magenta>0</font> <font color=Red>=</font> Nothing
<a name="line-109"></a>  <font color=Red>|</font> otherwise <font color=Red>=</font> <font color=Green><u>case</u></font> f g1 <font color=Green><u>of</u></font>
<a name="line-110"></a>      Just res <font color=Red>-&gt;</font> Just res
<a name="line-111"></a>      Nothing <font color=Red>-&gt;</font> try_for <font color=Cyan>(</font>n<font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font> f g2
<a name="line-112"></a>  <font color=Green><u>where</u></font>
<a name="line-113"></a>    <font color=Cyan>(</font>g1<font color=Cyan>,</font> g2<font color=Cyan>)</font> <font color=Red>=</font> split g    
<a name="line-114"></a>
<a name="line-115"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-116"></a><font color=Blue><i>-- * Square roots in &#8484;[&#8730;2]</i></font>
<a name="line-117"></a>
<a name="line-118"></a><a name="dinteger_root"></a><font color=Blue><i>-- | Return a square root of an element of &#8484;[&#8730;2], if such a square</i></font>
<a name="line-119"></a><font color=Blue><i>-- root exists, or else 'Nothing'.</i></font>
<a name="line-120"></a><font color=Blue>dinteger_root</font> <font color=Red>::</font> DInteger <font color=Red>-&gt;</font> Maybe DInteger
<a name="line-121"></a><font color=Blue>dinteger_root</font> z<font color=Red>@</font><font color=Cyan>(</font>RootTwo a b<font color=Cyan>)</font> <font color=Red>=</font> res <font color=Green><u>where</u></font>
<a name="line-122"></a>  d <font color=Red>=</font> a<font color=Cyan>^</font><font color=Magenta>2</font> <font color=Blue><i>-</i></font> <font color=Magenta>2</font><font color=Cyan>*</font>b<font color=Cyan>^</font><font color=Magenta>2</font>
<a name="line-123"></a>  r <font color=Red>=</font> intsqrt d
<a name="line-124"></a>  x1 <font color=Red>=</font> intsqrt <font color=Cyan>(</font><font color=Cyan>(</font>a <font color=Cyan>+</font> r<font color=Cyan>)</font> <font color=Cyan>`div`</font> <font color=Magenta>2</font><font color=Cyan>)</font>
<a name="line-125"></a>  x2 <font color=Red>=</font> intsqrt <font color=Cyan>(</font><font color=Cyan>(</font>a <font color=Blue><i>-</i></font> r<font color=Cyan>)</font> <font color=Cyan>`div`</font> <font color=Magenta>2</font><font color=Cyan>)</font>
<a name="line-126"></a>  y1 <font color=Red>=</font> intsqrt <font color=Cyan>(</font><font color=Cyan>(</font>a <font color=Blue><i>-</i></font> r<font color=Cyan>)</font> <font color=Cyan>`div`</font> <font color=Magenta>4</font><font color=Cyan>)</font>
<a name="line-127"></a>  y2 <font color=Red>=</font> intsqrt <font color=Cyan>(</font><font color=Cyan>(</font>a <font color=Cyan>+</font> r<font color=Cyan>)</font> <font color=Cyan>`div`</font> <font color=Magenta>4</font><font color=Cyan>)</font>
<a name="line-128"></a>  w1 <font color=Red>=</font> RootTwo x1 y1
<a name="line-129"></a>  w2 <font color=Red>=</font> RootTwo x2 y2
<a name="line-130"></a>  w3 <font color=Red>=</font> RootTwo x1 <font color=Cyan>(</font><font color=Blue><i>-</i></font>y1<font color=Cyan>)</font>
<a name="line-131"></a>  w4 <font color=Red>=</font> RootTwo x2 <font color=Cyan>(</font><font color=Blue><i>-</i></font>y2<font color=Cyan>)</font>
<a name="line-132"></a>  res 
<a name="line-133"></a>    <font color=Red>|</font> w1<font color=Cyan>*</font>w1 <font color=Cyan>==</font> z <font color=Red>=</font> Just w1
<a name="line-134"></a>    <font color=Red>|</font> w2<font color=Cyan>*</font>w2 <font color=Cyan>==</font> z <font color=Red>=</font> Just w2
<a name="line-135"></a>    <font color=Red>|</font> w3<font color=Cyan>*</font>w3 <font color=Cyan>==</font> z <font color=Red>=</font> Just w3
<a name="line-136"></a>    <font color=Red>|</font> w4<font color=Cyan>*</font>w4 <font color=Cyan>==</font> z <font color=Red>=</font> Just w4
<a name="line-137"></a>    <font color=Red>|</font> otherwise  <font color=Red>=</font> Nothing
<a name="line-138"></a>  
<a name="line-139"></a><font color=Blue><i>-- ----------------------------------------------------------------------  </i></font>
<a name="line-140"></a><font color=Blue><i>-- * Roots of &#8722;1 in &#8484;[sub /p/]</i></font>
<a name="line-141"></a>  
<a name="line-142"></a><a name="root_minus_one_step"></a><font color=Blue><i>-- | Input an integer /p/, and maybe output a root of &#8722;1 modulo /p/.</i></font>
<a name="line-143"></a><font color=Blue><i>-- This succeeds with probability at least 1\/2 if /p/ is a positive</i></font>
<a name="line-144"></a><font color=Blue><i>-- prime &#8801; 1 (mod 4); otherwise, the success probability is</i></font>
<a name="line-145"></a><font color=Blue><i>-- unspecified (and may be 0).</i></font>
<a name="line-146"></a><font color=Blue>root_minus_one_step</font> <font color=Red>::</font> <font color=Cyan>(</font>RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> Integer <font color=Red>-&gt;</font> g <font color=Red>-&gt;</font> Maybe Integer
<a name="line-147"></a><font color=Blue>root_minus_one_step</font> p g <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-148"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>b<font color=Cyan>,</font> <font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>=</font> randomR <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>,</font> p<font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font> g
<a name="line-149"></a>  <font color=Green><u>let</u></font> h <font color=Red>=</font> power mul <font color=Magenta>1</font> b <font color=Cyan>(</font><font color=Cyan>(</font>p<font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font> <font color=Cyan>`div`</font> <font color=Magenta>4</font><font color=Cyan>)</font>
<a name="line-150"></a>  ensure <font color=Cyan>$</font> h <font color=Cyan>`mul`</font> h <font color=Cyan>==</font> p<font color=Blue><i>-</i></font><font color=Magenta>1</font>  <font color=Blue><i>-- succeeds with probability 1/2</i></font>
<a name="line-151"></a>  return h
<a name="line-152"></a>    <font color=Green><u>where</u></font>
<a name="line-153"></a>      mul <font color=Red>::</font> Integer <font color=Red>-&gt;</font> Integer <font color=Red>-&gt;</font> Integer
<a name="line-154"></a>      mul a b <font color=Red>=</font> <font color=Cyan>(</font>a<font color=Cyan>*</font>b<font color=Cyan>)</font> <font color=Cyan>`mod`</font> p
<a name="line-155"></a>      
<a name="line-156"></a><a name="root_minus_one"></a><font color=Blue><i>-- | Input a positive prime /p/ &#8801; 1 (mod 4), and output a root of &#8722;1.</i></font>
<a name="line-157"></a><font color=Blue>root_minus_one</font> <font color=Red>::</font> <font color=Cyan>(</font>RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> Integer <font color=Red>-&gt;</font> g <font color=Red>-&gt;</font> Integer
<a name="line-158"></a><font color=Blue>root_minus_one</font> p <font color=Red>=</font> keeptrying <font color=Cyan>(</font>root_minus_one_step p<font color=Cyan>)</font>
<a name="line-159"></a>
<a name="line-160"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-161"></a><font color=Blue><i>-- * Solving a Diophantine equation</i></font>
<a name="line-162"></a>
<a name="line-163"></a><a name="dioph_step"></a><font color=Blue><i>-- | Input &#958; &#8712; &#8484;[&#8730;2], and maybe output some t &#8712; &#8484;[&#969;] such that </i></font>
<a name="line-164"></a><font color=Blue><i>-- t[sup &#8224;]t = &#958;. If &#958; &#8805; 0, &#958;[sup &#8226;] &#8805; 0, and /p/ = &#958;[sup &#8226;]&#958; is a</i></font>
<a name="line-165"></a><font color=Blue><i>-- prime &#8801; 1 (mod 4) in &#8484;, then this succeeds with probability at least</i></font>
<a name="line-166"></a><font color=Blue><i>-- 1\/2.  Otherwise, the success probability is unspecified and may be</i></font>
<a name="line-167"></a><font color=Blue><i>-- 0.</i></font>
<a name="line-168"></a><font color=Blue>dioph_step</font> <font color=Red>::</font> <font color=Cyan>(</font>RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> DInteger <font color=Red>-&gt;</font> g <font color=Red>-&gt;</font> Maybe ZOmega
<a name="line-169"></a><font color=Blue>dioph_step</font> xi g <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-170"></a>  h <font color=Red>&lt;-</font> root_minus_one_step <font color=Cyan>(</font>norm xi<font color=Cyan>)</font> g
<a name="line-171"></a>  <font color=Green><u>let</u></font> s <font color=Red>=</font> euclid_gcd <font color=Cyan>(</font>fromInteger h<font color=Cyan>+</font>i<font color=Cyan>)</font> <font color=Cyan>(</font>fromDInteger xi<font color=Cyan>)</font> <font color=Red>::</font> ZOmega
<a name="line-172"></a>      ss <font color=Red>=</font> dinteger_of_zomega <font color=Cyan>(</font>adj s <font color=Cyan>*</font> s<font color=Cyan>)</font>
<a name="line-173"></a>      u <font color=Red>=</font> euclid_div xi ss
<a name="line-174"></a>  v <font color=Red>&lt;-</font> dinteger_root u
<a name="line-175"></a>  <font color=Green><u>let</u></font> t <font color=Red>=</font> fromDInteger v <font color=Cyan>*</font> s
<a name="line-176"></a>  ensure <font color=Cyan>$</font> adj t <font color=Cyan>*</font> t <font color=Cyan>==</font> fromDInteger xi <font color=Blue><i>-- check the answer, just in case</i></font>
<a name="line-177"></a>  return t
<a name="line-178"></a>
<a name="line-179"></a><a name="dioph"></a><font color=Blue><i>-- | Input &#958; &#8712; &#8484;[&#8730;2] such that &#958; &#8805; 0, &#958;[sup &#8226;] &#8805; 0, and /p/ = </i></font>
<a name="line-180"></a><font color=Blue><i>-- &#958;[sup &#8226;]&#958; is a prime &#8801; 1 (mod 4) in &#8484;. Output t &#8712; &#8484;[&#969;] such that</i></font>
<a name="line-181"></a><font color=Blue><i>-- t[sup &#8224;]t = &#958;. If the hypotheses are not satisfied, this will</i></font>
<a name="line-182"></a><font color=Blue><i>-- likely loop forever.</i></font>
<a name="line-183"></a><font color=Blue>dioph</font> <font color=Red>::</font> <font color=Cyan>(</font>RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> DInteger <font color=Red>-&gt;</font> g <font color=Red>-&gt;</font> ZOmega
<a name="line-184"></a><font color=Blue>dioph</font> xi <font color=Red>=</font> keeptrying <font color=Cyan>(</font>dioph_step xi<font color=Cyan>)</font>
<a name="line-185"></a>
<a name="line-186"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-187"></a><font color=Blue><i>-- * Approximations in &#8484;[&#8730;2]</i></font>
<a name="line-188"></a>
<a name="line-189"></a><a name="gridpoints"></a><font color=Blue><i>-- | Input two intervals [/x/&#8320;, /x/&#8321;] &#8838; &#8477; and [/y/&#8320;, /y/&#8321;] &#8838; &#8477;. Output</i></font>
<a name="line-190"></a><font color=Blue><i>-- a list of all points /z/ = /a/ + &#8730;2/b/ &#8712; &#8484;[&#8730;2] such that /z/ &#8712;</i></font>
<a name="line-191"></a><font color=Blue><i>-- [/x/&#8320;, /x/&#8321;] and /z/[sup &#8226;] &#8712; [/y/&#8320;, /y/&#8321;]. The list will be</i></font>
<a name="line-192"></a><font color=Blue><i>-- produced lazily, and will be sorted in order of increasing /z/.</i></font>
<a name="line-193"></a><font color=Blue><i>-- </i></font>
<a name="line-194"></a><font color=Blue><i>-- It is a theorem that there will be at least one solution if &#916;x&#916;y &#8805; (1</i></font>
<a name="line-195"></a><font color=Blue><i>-- + &#8730;2)&#178;, and at most one solution if &#916;x&#916;y &lt; 1, where &#916;x = /x/&#8321; &#8722; /x/&#8320; &#8805; 0</i></font>
<a name="line-196"></a><font color=Blue><i>-- and &#916;y = /y/&#8321; &#8722; /y/&#8320; &#8805; 0. Asymptotically, the expected number of</i></font>
<a name="line-197"></a><font color=Blue><i>-- solutions is &#916;x&#916;y/\&#8730;8.</i></font>
<a name="line-198"></a><font color=Blue><i>-- </i></font>
<a name="line-199"></a><font color=Blue><i>-- This function is formulated so that the intervals can be specified</i></font>
<a name="line-200"></a><font color=Blue><i>-- exactly (using a type such as 'EReal'), or approximately (using a</i></font>
<a name="line-201"></a><font color=Blue><i>-- type such as 'Double' or 'FixedPrec' /e/).</i></font>
<a name="line-202"></a><font color=Blue>gridpoints</font> <font color=Red>::</font> <font color=Cyan>(</font>RootTwoRing r<font color=Cyan>,</font> Fractional r<font color=Cyan>,</font> Floor r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> ToReal r<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>r<font color=Cyan>,</font> r<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>r<font color=Cyan>,</font> r<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Red>[</font>DInteger<font color=Red>]</font>
<a name="line-203"></a><font color=Blue>gridpoints</font> <font color=Cyan>(</font>x0<font color=Cyan>,</font> x1<font color=Cyan>)</font> <font color=Cyan>(</font>y0<font color=Cyan>,</font> y1<font color=Cyan>)</font>
<a name="line-204"></a>  <font color=Red>|</font> dy <font color=Cyan>&lt;=</font> <font color=Magenta>0</font> <font color=Cyan>&amp;&amp;</font> dx <font color=Cyan>&gt;</font> <font color=Magenta>0</font> <font color=Red>=</font> 
<a name="line-205"></a>        map adj2 <font color=Cyan>$</font> gridpoints <font color=Cyan>(</font>y0<font color=Cyan>,</font> y1<font color=Cyan>)</font> <font color=Cyan>(</font>x0<font color=Cyan>,</font> x1<font color=Cyan>)</font>
<a name="line-206"></a>  <font color=Red>|</font> dy <font color=Cyan>&gt;=</font> lambda <font color=Cyan>&amp;&amp;</font> even n <font color=Red>=</font>
<a name="line-207"></a>        map <font color=Cyan>(</font>lambdainv<font color=Cyan>^</font>n <font color=Cyan>*</font><font color=Cyan>)</font> <font color=Cyan>$</font> gridpoints <font color=Cyan>(</font>lambda<font color=Cyan>^</font>n<font color=Cyan>*</font>x0<font color=Cyan>,</font> lambda<font color=Cyan>^</font>n<font color=Cyan>*</font>x1<font color=Cyan>)</font> <font color=Cyan>(</font>lambda'<font color=Cyan>^</font>n<font color=Cyan>*</font>y0<font color=Cyan>,</font> lambda'<font color=Cyan>^</font>n<font color=Cyan>*</font>y1<font color=Cyan>)</font>
<a name="line-208"></a>  <font color=Red>|</font> dy <font color=Cyan>&gt;=</font> lambda <font color=Cyan>&amp;&amp;</font> odd n <font color=Red>=</font>
<a name="line-209"></a>        map <font color=Cyan>(</font>lambdainv<font color=Cyan>^</font>n <font color=Cyan>*</font><font color=Cyan>)</font> <font color=Cyan>$</font> gridpoints <font color=Cyan>(</font>lambda<font color=Cyan>^</font>n<font color=Cyan>*</font>x0<font color=Cyan>,</font> lambda<font color=Cyan>^</font>n<font color=Cyan>*</font>x1<font color=Cyan>)</font> <font color=Cyan>(</font>lambda'<font color=Cyan>^</font>n<font color=Cyan>*</font>y1<font color=Cyan>,</font> lambda'<font color=Cyan>^</font>n<font color=Cyan>*</font>y0<font color=Cyan>)</font>
<a name="line-210"></a>  <font color=Red>|</font> dy <font color=Cyan>&gt;</font> <font color=Magenta>0</font> <font color=Cyan>&amp;&amp;</font> dy <font color=Cyan>&lt;</font> <font color=Magenta>1</font> <font color=Cyan>&amp;&amp;</font> even n <font color=Red>=</font> 
<a name="line-211"></a>        map <font color=Cyan>(</font>lambda<font color=Cyan>^</font>m <font color=Cyan>*</font><font color=Cyan>)</font> <font color=Cyan>$</font> gridpoints <font color=Cyan>(</font>lambdainv<font color=Cyan>^</font>m<font color=Cyan>*</font>x0<font color=Cyan>,</font> lambdainv<font color=Cyan>^</font>m<font color=Cyan>*</font>x1<font color=Cyan>)</font> <font color=Cyan>(</font>lambdainv'<font color=Cyan>^</font>m<font color=Cyan>*</font>y0<font color=Cyan>,</font> lambdainv'<font color=Cyan>^</font>m<font color=Cyan>*</font>y1<font color=Cyan>)</font>
<a name="line-212"></a>  <font color=Red>|</font> dy <font color=Cyan>&gt;</font> <font color=Magenta>0</font> <font color=Cyan>&amp;&amp;</font> dy <font color=Cyan>&lt;</font> <font color=Magenta>1</font> <font color=Cyan>&amp;&amp;</font> odd n <font color=Red>=</font> 
<a name="line-213"></a>        map <font color=Cyan>(</font>lambda<font color=Cyan>^</font>m <font color=Cyan>*</font><font color=Cyan>)</font> <font color=Cyan>$</font> gridpoints <font color=Cyan>(</font>lambdainv<font color=Cyan>^</font>m<font color=Cyan>*</font>x0<font color=Cyan>,</font> lambdainv<font color=Cyan>^</font>m<font color=Cyan>*</font>x1<font color=Cyan>)</font> <font color=Cyan>(</font>lambdainv'<font color=Cyan>^</font>m<font color=Cyan>*</font>y1<font color=Cyan>,</font> lambdainv'<font color=Cyan>^</font>m<font color=Cyan>*</font>y0<font color=Cyan>)</font>
<a name="line-214"></a>  <font color=Red>|</font> otherwise <font color=Red>=</font>
<a name="line-215"></a>        <font color=Red>[</font> RootTwo a b <font color=Red>|</font> a <font color=Red>&lt;-</font> <font color=Red>[</font>amin<font color=Red>..</font>amax<font color=Red>]</font><font color=Cyan>,</font> b <font color=Red>&lt;-</font> <font color=Red>[</font>bmin a<font color=Red>..</font>bmax a<font color=Red>]</font><font color=Cyan>,</font> test a b <font color=Red>]</font> 
<a name="line-216"></a>  <font color=Green><u>where</u></font>
<a name="line-217"></a>    dx <font color=Red>=</font> x1 <font color=Blue><i>-</i></font> x0
<a name="line-218"></a>    dy <font color=Red>=</font> y1 <font color=Blue><i>-</i></font> y0
<a name="line-219"></a>    <font color=Cyan>(</font>n<font color=Cyan>,</font> <font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>=</font> floorlog lambda dy
<a name="line-220"></a>    m <font color=Red>=</font> <font color=Blue><i>-</i></font>n
<a name="line-221"></a>    
<a name="line-222"></a>    lambda <font color=Red>::</font> <font color=Cyan>(</font>RootTwoRing r<font color=Cyan>)</font> <font color=Red>=&gt;</font> r
<a name="line-223"></a>    lambda <font color=Red>=</font> <font color=Magenta>1</font> <font color=Cyan>+</font> roottwo
<a name="line-224"></a>    lambda' <font color=Red>::</font> <font color=Cyan>(</font>RootTwoRing r<font color=Cyan>)</font> <font color=Red>=&gt;</font> r
<a name="line-225"></a>    lambda' <font color=Red>=</font> <font color=Magenta>1</font> <font color=Blue><i>-</i></font> roottwo
<a name="line-226"></a>    lambdainv <font color=Red>::</font> <font color=Cyan>(</font>RootTwoRing r<font color=Cyan>)</font> <font color=Red>=&gt;</font> r
<a name="line-227"></a>    lambdainv <font color=Red>=</font> <font color=Blue><i>-</i></font><font color=Magenta>1</font> <font color=Cyan>+</font> roottwo
<a name="line-228"></a>    lambdainv' <font color=Red>::</font> <font color=Cyan>(</font>RootTwoRing r<font color=Cyan>)</font> <font color=Red>=&gt;</font> r
<a name="line-229"></a>    lambdainv' <font color=Red>=</font> <font color=Blue><i>-</i></font><font color=Magenta>1</font> <font color=Blue><i>-</i></font> roottwo
<a name="line-230"></a>
<a name="line-231"></a>    within x <font color=Cyan>(</font>x0<font color=Cyan>,</font> x1<font color=Cyan>)</font> <font color=Red>=</font> x0 <font color=Cyan>&lt;=</font> x <font color=Cyan>&amp;&amp;</font> x <font color=Cyan>&lt;=</font> x1
<a name="line-232"></a>    amin <font color=Red>=</font> ceiling_of <font color=Cyan>(</font><font color=Cyan>(</font>x0 <font color=Cyan>+</font> y0<font color=Cyan>)</font> <font color=Cyan>/</font> <font color=Magenta>2</font><font color=Cyan>)</font>
<a name="line-233"></a>    amax <font color=Red>=</font> floor_of <font color=Cyan>(</font><font color=Cyan>(</font>x1 <font color=Cyan>+</font> y1<font color=Cyan>)</font> <font color=Cyan>/</font> <font color=Magenta>2</font><font color=Cyan>)</font>
<a name="line-234"></a>    bmin a <font color=Red>=</font> ceiling_of <font color=Cyan>(</font><font color=Cyan>(</font>fromInteger a <font color=Blue><i>-</i></font> y1<font color=Cyan>)</font> <font color=Cyan>/</font> roottwo<font color=Cyan>)</font>
<a name="line-235"></a>    bmax a <font color=Red>=</font> floor_of <font color=Cyan>(</font><font color=Cyan>(</font>fromInteger a <font color=Blue><i>-</i></font> y0<font color=Cyan>)</font> <font color=Cyan>/</font> roottwo<font color=Cyan>)</font>
<a name="line-236"></a>    test a b <font color=Red>=</font> fromDInteger x <font color=Cyan>`within`</font> <font color=Cyan>(</font>x0<font color=Cyan>,</font> x1<font color=Cyan>)</font> <font color=Cyan>&amp;&amp;</font> fromDInteger <font color=Cyan>(</font>adj2 x<font color=Cyan>)</font> <font color=Cyan>`within`</font> <font color=Cyan>(</font>y0<font color=Cyan>,</font> y1<font color=Cyan>)</font>
<a name="line-237"></a>      <font color=Green><u>where</u></font> x <font color=Red>=</font> RootTwo a b
<a name="line-238"></a>
<a name="line-239"></a><a name="gridpoint_random"></a><font color=Blue><i>-- | Input two intervals [/x/&#8320;, /x/&#8321;] &#8838; &#8477; and [/y/&#8320;, /y/&#8321;] &#8838; &#8477; and a</i></font>
<a name="line-240"></a><font color=Blue><i>-- source of randomness. Output a random element /z/ = /a/ + &#8730;2/b/</i></font>
<a name="line-241"></a><font color=Blue><i>-- &#8712; &#8484;[&#8730;2] such that /z/ &#8712; [/x/&#8320;, /x/&#8321;] and /z/[sup &#8226;] &#8712; [/y/&#8320;,</i></font>
<a name="line-242"></a><font color=Blue><i>-- /y/&#8321;]. </i></font>
<a name="line-243"></a><font color=Blue><i>-- </i></font>
<a name="line-244"></a><font color=Blue><i>-- Note: the randomness will not be uniform. To ensure that the set of</i></font>
<a name="line-245"></a><font color=Blue><i>-- solutions is non-empty, we must have &#916;x&#916;y &#8805; (1 + &#8730;2)&#178;, where &#916;x =</i></font>
<a name="line-246"></a><font color=Blue><i>-- /x/&#8321; &#8722; /x/&#8320; &#8805; 0 and &#916;y = /y/&#8321; &#8722; /y/&#8320; &#8805; 0. If there are no solutions</i></font>
<a name="line-247"></a><font color=Blue><i>-- at all, the function will return 'Nothing'.</i></font>
<a name="line-248"></a><font color=Blue><i>-- </i></font>
<a name="line-249"></a><font color=Blue><i>-- This function is formulated so that the intervals can be specified</i></font>
<a name="line-250"></a><font color=Blue><i>-- exactly (using a type such as 'EReal'), or approximately (using a</i></font>
<a name="line-251"></a><font color=Blue><i>-- type such as 'Double' or 'FixedPrec' /e/).</i></font>
<a name="line-252"></a><font color=Blue>gridpoint_random</font> <font color=Red>::</font> <font color=Cyan>(</font>RootTwoRing r<font color=Cyan>,</font> Fractional r<font color=Cyan>,</font> Floor r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> ToReal r<font color=Cyan>,</font> RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>r<font color=Cyan>,</font> r<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>r<font color=Cyan>,</font> r<font color=Cyan>)</font> <font color=Red>-&gt;</font> g <font color=Red>-&gt;</font> Maybe DInteger
<a name="line-253"></a><font color=Blue>gridpoint_random</font> <font color=Cyan>(</font>x0<font color=Cyan>,</font> x1<font color=Cyan>)</font> <font color=Cyan>(</font>y0<font color=Cyan>,</font> y1<font color=Cyan>)</font> g <font color=Red>=</font> z
<a name="line-254"></a>  <font color=Green><u>where</u></font>
<a name="line-255"></a>    dx <font color=Red>=</font> max <font color=Magenta>0</font> <font color=Cyan>(</font>x1 <font color=Blue><i>-</i></font> x0<font color=Cyan>)</font>
<a name="line-256"></a>    dy <font color=Red>=</font> max <font color=Magenta>0</font> <font color=Cyan>(</font>y1 <font color=Blue><i>-</i></font> y0<font color=Cyan>)</font>
<a name="line-257"></a>    area <font color=Red>=</font> dx <font color=Cyan>*</font> dy
<a name="line-258"></a>    n <font color=Red>=</font> floor_of <font color=Cyan>(</font>area <font color=Cyan>+</font> <font color=Magenta>1</font><font color=Cyan>)</font>
<a name="line-259"></a>    <font color=Cyan>(</font>i<font color=Cyan>,</font><font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>=</font> randomR <font color=Cyan>(</font><font color=Magenta>0</font><font color=Cyan>,</font> n<font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font> g
<a name="line-260"></a>    r <font color=Red>=</font> fromInteger i <font color=Cyan>/</font> fromInteger n
<a name="line-261"></a>    pts <font color=Red>=</font> gridpoints <font color=Cyan>(</font>x0 <font color=Cyan>+</font> r <font color=Cyan>*</font> dx<font color=Cyan>,</font> x1<font color=Cyan>)</font> <font color=Cyan>(</font>y0<font color=Cyan>,</font> y1<font color=Cyan>)</font> <font color=Cyan>++</font> gridpoints <font color=Cyan>(</font>x0<font color=Cyan>,</font> x1<font color=Cyan>)</font> <font color=Cyan>(</font>y0<font color=Cyan>,</font> y1<font color=Cyan>)</font>
<a name="line-262"></a>    z <font color=Red>=</font> maybe_head pts
<a name="line-263"></a>
<a name="line-264"></a><a name="gridpoint_random_parity"></a><font color=Blue><i>-- | Input an integer /e/, two intervals [/x/&#8320;, /x/&#8321;] &#8838; &#8477; and [/y/&#8320;,</i></font>
<a name="line-265"></a><font color=Blue><i>-- /y/&#8321;] &#8838; &#8477;, and a source of randomness. Output random /z/ = /a/ +</i></font>
<a name="line-266"></a><font color=Blue><i>-- &#8730;2/b/ &#8712; &#8484;[&#8730;2] such that /a/ + &#8730;2/b/ &#8712; [/x/&#8320;, /x/&#8321;], /a/ - &#8730;2/b/ &#8712;</i></font>
<a name="line-267"></a><font color=Blue><i>-- [/y/&#8320;, /y/&#8321;], and /a/-/e/ is even.</i></font>
<a name="line-268"></a><font color=Blue><i>-- </i></font>
<a name="line-269"></a><font color=Blue><i>-- Note: the randomness will not be uniform. To ensure that the set of</i></font>
<a name="line-270"></a><font color=Blue><i>-- solutions is non-empty, we must have &#916;x&#916;y &#8805; 2(&#8730;2 + 1)&#178;, where &#916;x =</i></font>
<a name="line-271"></a><font color=Blue><i>-- /x/&#8321; &#8722; /x/&#8320; &#8805; 0 and &#916;y = /y/&#8321; &#8722; /y/&#8320; &#8805; 0. If there are no solutions</i></font>
<a name="line-272"></a><font color=Blue><i>-- at all, the function will return 'Nothing'.</i></font>
<a name="line-273"></a><font color=Blue><i>-- </i></font>
<a name="line-274"></a><font color=Blue><i>-- This function is formulated so that the intervals can be specified</i></font>
<a name="line-275"></a><font color=Blue><i>-- exactly (using a type such as 'EReal'), or approximately (using a</i></font>
<a name="line-276"></a><font color=Blue><i>-- type such as 'Double' or 'FixedPrec' /e/).</i></font>
<a name="line-277"></a><font color=Blue>gridpoint_random_parity</font> <font color=Red>::</font> <font color=Cyan>(</font>RootTwoRing r<font color=Cyan>,</font> Fractional r<font color=Cyan>,</font> Floor r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> ToReal r<font color=Cyan>,</font> RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> Integer <font color=Red>-&gt;</font> <font color=Cyan>(</font>r<font color=Cyan>,</font> r<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>r<font color=Cyan>,</font> r<font color=Cyan>)</font> <font color=Red>-&gt;</font> g <font color=Red>-&gt;</font> Maybe DInteger
<a name="line-278"></a><font color=Blue>gridpoint_random_parity</font> e <font color=Cyan>(</font>x0<font color=Cyan>,</font>x1<font color=Cyan>)</font> <font color=Cyan>(</font>y0<font color=Cyan>,</font>y1<font color=Cyan>)</font> g <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-279"></a>  z' <font color=Red>&lt;-</font> gridpoint_random <font color=Cyan>(</font>x0'<font color=Cyan>,</font> x1'<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font>y1'<font color=Cyan>,</font> <font color=Blue><i>-</i></font>y0'<font color=Cyan>)</font> g
<a name="line-280"></a>  return <font color=Cyan>(</font>roottwo <font color=Cyan>*</font> z' <font color=Cyan>+</font> fromInteger e2<font color=Cyan>)</font>
<a name="line-281"></a>  <font color=Green><u>where</u></font> 
<a name="line-282"></a>    x0' <font color=Red>=</font> <font color=Cyan>(</font>x0 <font color=Blue><i>-</i></font> e'<font color=Cyan>)</font> <font color=Cyan>/</font> roottwo
<a name="line-283"></a>    x1' <font color=Red>=</font> <font color=Cyan>(</font>x1 <font color=Blue><i>-</i></font> e'<font color=Cyan>)</font> <font color=Cyan>/</font> roottwo
<a name="line-284"></a>    y0' <font color=Red>=</font> <font color=Cyan>(</font>y0 <font color=Blue><i>-</i></font> e'<font color=Cyan>)</font> <font color=Cyan>/</font> roottwo
<a name="line-285"></a>    y1' <font color=Red>=</font> <font color=Cyan>(</font>y1 <font color=Blue><i>-</i></font> e'<font color=Cyan>)</font> <font color=Cyan>/</font> roottwo
<a name="line-286"></a>    e' <font color=Red>=</font> fromInteger e2
<a name="line-287"></a>    e2 <font color=Red>=</font> e <font color=Cyan>`mod`</font> <font color=Magenta>2</font>
<a name="line-288"></a>
<a name="line-289"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-290"></a><font color=Blue><i>-- * Approximate synthesis</i></font>
<a name="line-291"></a>  
<a name="line-292"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-293"></a><font color=Blue><i>-- ** The main algorithm</i></font>
<a name="line-294"></a>
<a name="line-295"></a><a name="newsynth_step"></a><font color=Blue><i>-- | The internal implementation of the approximate synthesis</i></font>
<a name="line-296"></a><font color=Blue><i>-- algorithm. The parameters are:</i></font>
<a name="line-297"></a><font color=Blue><i>-- </i></font>
<a name="line-298"></a><font color=Blue><i>-- * an angle &#952;, to implement a /R/[sub /z/](&#952;) = [exp &#8722;/i/&#952;/Z/\/2]</i></font>
<a name="line-299"></a><font color=Blue><i>-- gate;</i></font>
<a name="line-300"></a><font color=Blue><i>--   </i></font>
<a name="line-301"></a><font color=Blue><i>-- * a precision /p/ &#8805; 0 in bits, such that &#949; = 2[sup -/p/];</i></font>
<a name="line-302"></a><font color=Blue><i>-- </i></font>
<a name="line-303"></a><font color=Blue><i>-- * a source of randomness /g/.</i></font>
<a name="line-304"></a><font color=Blue><i>-- </i></font>
<a name="line-305"></a><font color=Blue><i>-- With some probability, output a unitary operator in the</i></font>
<a name="line-306"></a><font color=Blue><i>-- Clifford+/T/ group that approximates /R/[sub /z/](&#952;) to within &#949; in</i></font>
<a name="line-307"></a><font color=Blue><i>-- the operator norm. This operator can then be converted to a list of</i></font>
<a name="line-308"></a><font color=Blue><i>-- gates with 'to_gates'. Also output log[sub 0.1] of the actual</i></font>
<a name="line-309"></a><font color=Blue><i>-- error, or 'Nothing' if the error is 0.</i></font>
<a name="line-310"></a><font color=Blue><i>-- </i></font>
<a name="line-311"></a><font color=Blue><i>-- This implementation does not use seeding.</i></font>
<a name="line-312"></a><font color=Blue><i>-- </i></font>
<a name="line-313"></a><font color=Blue><i>-- As a special case, if the /R/[sub /z/](&#952;) is a Clifford operator</i></font>
<a name="line-314"></a><font color=Blue><i>-- (to within the given &#949;), always return this operator directly.</i></font>
<a name="line-315"></a><font color=Blue><i>-- </i></font>
<a name="line-316"></a><font color=Blue><i>-- Note: the parameter &#952; must be of a real number type that has enough</i></font>
<a name="line-317"></a><font color=Blue><i>-- precision to perform intermediate calculations; the typically</i></font>
<a name="line-318"></a><font color=Blue><i>-- requires precision O(&#949;[sup 2]).  A more user-friendly function that</i></font>
<a name="line-319"></a><font color=Blue><i>-- does this automatically is 'newsynth'.</i></font>
<a name="line-320"></a><font color=Blue>newsynth_step</font> <font color=Red>::</font> <font color=Green><u>forall</u></font> r g<font color=Cyan>.</font><font color=Cyan>(</font>RealFrac r<font color=Cyan>,</font> Floating r<font color=Cyan>,</font> RootHalfRing r<font color=Cyan>,</font> Floor r<font color=Cyan>,</font> Adjoint r<font color=Cyan>,</font> ToReal r<font color=Cyan>,</font> RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> r <font color=Red>-&gt;</font> r <font color=Red>-&gt;</font> g <font color=Red>-&gt;</font> Maybe <font color=Cyan>(</font>U2 DOmega<font color=Cyan>,</font> Maybe Double<font color=Cyan>)</font>
<a name="line-321"></a><font color=Blue>newsynth_step</font> prec theta <font color=Red>=</font> payload <font color=Green><u>where</u></font>
<a name="line-322"></a>  <font color=Blue><i>-- We are careful to do all computations that depend only on epsilon</i></font>
<a name="line-323"></a>  <font color=Blue><i>-- and theta (but not g) outside of aux, to avoid re-computing them</i></font>
<a name="line-324"></a>  <font color=Blue><i>-- with each attempt.</i></font>
<a name="line-325"></a>  
<a name="line-326"></a>  <font color=Blue><i>-- Calculate &#949;.</i></font>
<a name="line-327"></a>  epsilon <font color=Red>=</font> <font color=Magenta>2</font> <font color=Cyan>**</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font>prec<font color=Cyan>)</font>
<a name="line-328"></a>  
<a name="line-329"></a>  <font color=Blue><i>-- Convert prec to a Double</i></font>
<a name="line-330"></a>  dprec <font color=Red>=</font> fromRational <font color=Cyan>(</font>toRational prec<font color=Cyan>)</font>
<a name="line-331"></a>  
<a name="line-332"></a>  <font color=Blue><i>-- Determine k.</i></font>
<a name="line-333"></a>  const <font color=Red>=</font> <font color=Magenta>3</font> <font color=Cyan>+</font> <font color=Magenta>2</font> <font color=Cyan>*</font> logBase <font color=Magenta>2</font> <font color=Cyan>(</font><font color=Magenta>1</font> <font color=Cyan>+</font> sqrt <font color=Magenta>2</font><font color=Cyan>)</font> <font color=Red>::</font> Double
<a name="line-334"></a>  k <font color=Red>=</font> ceiling <font color=Cyan>(</font>const <font color=Cyan>+</font> <font color=Magenta>2</font> <font color=Cyan>*</font> dprec<font color=Cyan>)</font>
<a name="line-335"></a>  scale <font color=Red>=</font> roottwo<font color=Cyan>^</font>k
<a name="line-336"></a>  
<a name="line-337"></a>  <font color=Blue><i>-- Normalize &#952; to be in [-&#960;/4, &#960;/4].</i></font>
<a name="line-338"></a>  n <font color=Red>=</font> round<font color=Cyan>(</font>theta <font color=Cyan>/</font> <font color=Cyan>(</font>pi<font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-339"></a>  theta1 <font color=Red>=</font> theta <font color=Blue><i>-</i></font> fromInteger n <font color=Cyan>*</font> pi<font color=Cyan>/</font><font color=Magenta>2</font>
<a name="line-340"></a>  
<a name="line-341"></a>  <font color=Blue><i>-- Describe the &#949;-region.</i></font>
<a name="line-342"></a>  z <font color=Red>@</font> <font color=Cyan>(</font>x<font color=Cyan>,</font>y<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>cos <font color=Cyan>(</font>theta1 <font color=Cyan>/</font> <font color=Magenta>2</font><font color=Cyan>)</font><font color=Cyan>,</font> <font color=Blue><i>-</i></font>sin <font color=Cyan>(</font>theta1 <font color=Cyan>/</font> <font color=Magenta>2</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-343"></a>  e2 <font color=Red>=</font> <font color=Magenta>1</font> <font color=Blue><i>-</i></font> epsilon<font color=Cyan>^</font><font color=Magenta>2</font><font color=Cyan>/</font><font color=Magenta>2</font>
<a name="line-344"></a>  e4 <font color=Red>=</font> <font color=Magenta>1</font> <font color=Blue><i>-</i></font> epsilon<font color=Cyan>^</font><font color=Magenta>2</font><font color=Cyan>/</font><font color=Magenta>4</font>
<a name="line-345"></a>  z1 <font color=Red>@</font> <font color=Cyan>(</font>x1<font color=Cyan>,</font>y1<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>e4 <font color=Cyan>*</font> x<font color=Cyan>,</font> e4 <font color=Cyan>*</font> y<font color=Cyan>)</font>
<a name="line-346"></a>  e' <font color=Red>=</font> epsilon <font color=Cyan>/</font> roottwo
<a name="line-347"></a>  f <font color=Red>=</font> e' <font color=Cyan>*</font> sqrt<font color=Cyan>(</font><font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>+</font>e'<font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font><font color=Cyan>*</font><font color=Cyan>(</font><font color=Magenta>1</font><font color=Blue><i>-</i></font>e'<font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font><font color=Cyan>)</font> <font color=Blue><i>-- == sqrt(1-e4^2)</i></font>
<a name="line-348"></a>  w <font color=Red>@</font> <font color=Cyan>(</font>wx<font color=Cyan>,</font>wy<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font>f <font color=Cyan>*</font> y<font color=Cyan>,</font> f <font color=Cyan>*</font> x<font color=Cyan>)</font>
<a name="line-349"></a>  y_min <font color=Red>=</font> y1 <font color=Blue><i>-</i></font> wy
<a name="line-350"></a>  y_max <font color=Red>=</font> y1 <font color=Cyan>+</font> wy
<a name="line-351"></a>  y'_min <font color=Red>=</font> y_min <font color=Cyan>*</font> scale
<a name="line-352"></a>  y'_max <font color=Red>=</font> y_max <font color=Cyan>*</font> scale
<a name="line-353"></a>  dx <font color=Red>=</font> <font color=Cyan>(</font>e4 <font color=Blue><i>-</i></font> e2<font color=Cyan>)</font> <font color=Cyan>*</font> x
<a name="line-354"></a>  
<a name="line-355"></a>  find_uU_step <font color=Red>=</font> 
<a name="line-356"></a>    <font color=Blue><i>-- As a special case, if (1,0) is in the &#949;-region, return the</i></font>
<a name="line-357"></a>    <font color=Blue><i>-- identity operator.</i></font>
<a name="line-358"></a>    <font color=Green><u>if</u></font> x <font color=Cyan>&gt;=</font> e2 <font color=Green><u>then</u></font> <font color=Red>\</font>g <font color=Red>-&gt;</font> Just <font color=Magenta>1</font> <font color=Green><u>else</u></font> aux
<a name="line-359"></a>
<a name="line-360"></a>  <font color=Blue><i>-- The rest of the computation depends on the random seed g.</i></font>
<a name="line-361"></a>  payload g <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-362"></a>    uU1 <font color=Red>&lt;-</font> find_uU_step g  
<a name="line-363"></a>    <font color=Green><u>let</u></font> uU <font color=Red>=</font> correct uU1 n
<a name="line-364"></a>    <font color=Green><u>let</u></font> err <font color=Red>=</font> calc_error uU theta
<a name="line-365"></a>    return <font color=Cyan>(</font>uU<font color=Cyan>,</font> err<font color=Cyan>)</font>
<a name="line-366"></a>  
<a name="line-367"></a>  aux g <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-368"></a>    <font color=Blue><i>-- Find a random grid point in the &#949;-region.</i></font>
<a name="line-369"></a>    <font color=Green><u>let</u></font> <font color=Cyan>(</font>g0<font color=Cyan>,</font>g1<font color=Cyan>)</font> <font color=Red>=</font> split g
<a name="line-370"></a>    beta <font color=Red>&lt;-</font> gridpoint_random <font color=Cyan>(</font>y'_min<font color=Cyan>,</font> y'_max<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font>roothalf <font color=Cyan>*</font> scale<font color=Cyan>,</font> roothalf <font color=Cyan>*</font> scale<font color=Cyan>)</font> g0
<a name="line-371"></a>    <font color=Green><u>let</u></font>  
<a name="line-372"></a>      beta' <font color=Red>=</font> fromDInteger beta <font color=Cyan>/</font> scale
<a name="line-373"></a>      tmp <font color=Red>=</font> <font color=Cyan>(</font>beta' <font color=Blue><i>-</i></font> e2 <font color=Cyan>*</font> y<font color=Cyan>)</font> <font color=Cyan>/</font> wy
<a name="line-374"></a>      x0 <font color=Red>=</font> e2 <font color=Cyan>*</font> x <font color=Cyan>+</font> tmp <font color=Cyan>*</font> wx
<a name="line-375"></a>      x1 <font color=Red>=</font> x0 <font color=Cyan>+</font> dx
<a name="line-376"></a>      x0' <font color=Red>=</font> x0 <font color=Cyan>*</font> scale
<a name="line-377"></a>      x1' <font color=Red>=</font> x1 <font color=Cyan>*</font> scale
<a name="line-378"></a>      <font color=Cyan>(</font>g2<font color=Cyan>,</font>g3<font color=Cyan>)</font> <font color=Red>=</font> split g1
<a name="line-379"></a>      RootTwo c <font color=Green><u>_</u></font> <font color=Red>=</font> beta
<a name="line-380"></a>    alpha <font color=Red>&lt;-</font> gridpoint_random_parity <font color=Cyan>(</font>c<font color=Cyan>+</font><font color=Magenta>1</font><font color=Cyan>)</font> <font color=Cyan>(</font>x0'<font color=Cyan>,</font> x1'<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font>roothalf <font color=Cyan>*</font> scale<font color=Cyan>,</font> roothalf <font color=Cyan>*</font> scale<font color=Cyan>)</font> g2
<a name="line-381"></a>    
<a name="line-382"></a>    <font color=Blue><i>-- Calculate u, &#958;, and solve Diophantine equation to calculate t.</i></font>
<a name="line-383"></a>    <font color=Green><u>let</u></font>  
<a name="line-384"></a>      u <font color=Red>=</font> <font color=Cyan>(</font>fromDInteger alpha<font color=Cyan>)</font> <font color=Cyan>+</font> i <font color=Cyan>*</font> <font color=Cyan>(</font>fromDInteger beta<font color=Cyan>)</font> <font color=Red>::</font> ZOmega
<a name="line-385"></a>      xi <font color=Red>=</font> dinteger_of_zomega <font color=Cyan>(</font><font color=Magenta>2</font><font color=Cyan>^</font>k <font color=Blue><i>-</i></font> u <font color=Cyan>*</font> adj u<font color=Cyan>)</font>
<a name="line-386"></a>    t <font color=Red>&lt;-</font> dioph_step xi g3
<a name="line-387"></a>    
<a name="line-388"></a>    <font color=Blue><i>-- If Diophantine equation solved successfully, calculate matrix U.</i></font>
<a name="line-389"></a>    <font color=Green><u>let</u></font>
<a name="line-390"></a>      u' <font color=Red>=</font> fromZOmega u <font color=Cyan>*</font> roothalf<font color=Cyan>^</font>k <font color=Red>::</font> DOmega
<a name="line-391"></a>      t' <font color=Red>=</font> fromZOmega t <font color=Cyan>*</font> roothalf<font color=Cyan>^</font>k <font color=Red>::</font> DOmega
<a name="line-392"></a>      uU1 <font color=Red>=</font> matrix2x2 <font color=Cyan>(</font>u'<font color=Cyan>,</font> <font color=Blue><i>-</i></font><font color=Cyan>(</font>adj t'<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-393"></a>                      <font color=Cyan>(</font>t'<font color=Cyan>,</font>  <font color=Cyan>(</font>adj u'<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-394"></a>           
<a name="line-395"></a>    return uU1
<a name="line-396"></a>    
<a name="line-397"></a>  <font color=Blue><i>-- Correct for when &#952; wasn't in [-&#960;/4, &#960;/4].</i></font>
<a name="line-398"></a>  correct uU1 n <font color=Red>=</font> uU1 <font color=Cyan>*</font> rR<font color=Cyan>^</font><font color=Cyan>(</font>n <font color=Cyan>`mod`</font> <font color=Magenta>8</font><font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-399"></a>    rR <font color=Red>=</font> matrix2x2 <font color=Cyan>(</font>omega<font color=Cyan>^</font><font color=Magenta>7</font><font color=Cyan>,</font> <font color=Magenta>0</font><font color=Cyan>)</font>
<a name="line-400"></a>                   <font color=Cyan>(</font><font color=Magenta>0</font><font color=Cyan>,</font>   omega<font color=Cyan>)</font>
<a name="line-401"></a>    
<a name="line-402"></a>  <font color=Blue><i>-- Calculate the actual error. Since this is done lazily, this</i></font>
<a name="line-403"></a>  <font color=Blue><i>-- incurs no overhead in case the error is not actually used.</i></font>
<a name="line-404"></a>  calc_error uU theta <font color=Red>=</font> log_err <font color=Green><u>where</u></font>
<a name="line-405"></a>    uU_fixed <font color=Red>=</font> matrix_map fromDOmega uU <font color=Red>::</font> U2 <font color=Cyan>(</font>Cplx r<font color=Cyan>)</font>
<a name="line-406"></a>    zrot_fixed <font color=Red>=</font> zrot theta <font color=Red>::</font> U2 <font color=Cyan>(</font>Cplx r<font color=Cyan>)</font>
<a name="line-407"></a>    err <font color=Red>=</font> sqrt <font color=Cyan>(</font>real <font color=Cyan>(</font>hs_sqnorm <font color=Cyan>(</font>uU_fixed <font color=Blue><i>-</i></font> zrot_fixed<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>/</font> <font color=Magenta>2</font><font color=Cyan>)</font>
<a name="line-408"></a>    log_err 
<a name="line-409"></a>      <font color=Red>|</font> err <font color=Cyan>&lt;=</font> <font color=Magenta>0</font>  <font color=Red>=</font> Nothing
<a name="line-410"></a>      <font color=Red>|</font> otherwise <font color=Red>=</font> Just <font color=Cyan>(</font>log_double err <font color=Cyan>/</font> log <font color=Magenta>0.1</font><font color=Cyan>)</font>
<a name="line-411"></a>
<a name="line-412"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-413"></a><font color=Blue><i>-- ** User-friendly functions</i></font>
<a name="line-414"></a>
<a name="line-415"></a><a name="newsynth"></a><font color=Blue><i>-- | A user-friendly interface to the approximate synthesis</i></font>
<a name="line-416"></a><font color=Blue><i>-- algorithm. The parameters are:</i></font>
<a name="line-417"></a><font color=Blue><i>-- </i></font>
<a name="line-418"></a><font color=Blue><i>-- * an angle &#952;, to implement a /R/[sub /z/](&#952;) = [exp &#8722;/i/&#952;/Z/\/2]</i></font>
<a name="line-419"></a><font color=Blue><i>-- gate;</i></font>
<a name="line-420"></a><font color=Blue><i>--   </i></font>
<a name="line-421"></a><font color=Blue><i>-- * a precision /b/ &#8805; 0 in bits, such that &#949; = 2[sup -/b/];</i></font>
<a name="line-422"></a><font color=Blue><i>-- </i></font>
<a name="line-423"></a><font color=Blue><i>-- * a source of randomness /g/.</i></font>
<a name="line-424"></a><font color=Blue><i>-- </i></font>
<a name="line-425"></a><font color=Blue><i>-- Output a unitary operator in the Clifford+/T/ group that</i></font>
<a name="line-426"></a><font color=Blue><i>-- approximates /R/[sub /z/](&#952;) to within &#949; in the operator norm. This</i></font>
<a name="line-427"></a><font color=Blue><i>-- operator can then be converted to a list of gates with</i></font>
<a name="line-428"></a><font color=Blue><i>-- 'to_gates'.</i></font>
<a name="line-429"></a><font color=Blue><i>-- </i></font>
<a name="line-430"></a><font color=Blue><i>-- This implementation does not use seeding.</i></font>
<a name="line-431"></a><font color=Blue><i>-- </i></font>
<a name="line-432"></a><font color=Blue><i>-- Note: the argument /theta/ is given as a symbolic real number. It</i></font>
<a name="line-433"></a><font color=Blue><i>-- will automatically be expanded to as many digits as are necessary</i></font>
<a name="line-434"></a><font color=Blue><i>-- for the internal calculation. In this way, the caller can specify,</i></font>
<a name="line-435"></a><font color=Blue><i>-- e.g., an angle of 'pi'\/128 @::@ 'SymReal', without having to worry</i></font>
<a name="line-436"></a><font color=Blue><i>-- about how many digits of &#960; to specify.</i></font>
<a name="line-437"></a><font color=Blue>newsynth</font> <font color=Red>::</font> <font color=Cyan>(</font>RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> Double <font color=Red>-&gt;</font> SymReal <font color=Red>-&gt;</font> g <font color=Red>-&gt;</font> U2 DOmega
<a name="line-438"></a><font color=Blue>newsynth</font> prec theta g <font color=Red>=</font> m <font color=Green><u>where</u></font>
<a name="line-439"></a>  <font color=Cyan>(</font>m<font color=Cyan>,</font> <font color=Green><u>_</u></font><font color=Cyan>,</font> <font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>=</font> newsynth_stats prec theta g
<a name="line-440"></a>
<a name="line-441"></a><a name="newsynth_stats"></a><font color=Blue><i>-- | A version of 'newsynth' that also returns some statistics:</i></font>
<a name="line-442"></a><font color=Blue><i>-- log[sub 0.1] of the actual approximation error (or 'Nothing' if the</i></font>
<a name="line-443"></a><font color=Blue><i>-- error is 0), and the number of candidates tried.</i></font>
<a name="line-444"></a><font color=Blue>newsynth_stats</font> <font color=Red>::</font> <font color=Cyan>(</font>RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> Double <font color=Red>-&gt;</font> SymReal <font color=Red>-&gt;</font> g <font color=Red>-&gt;</font> <font color=Cyan>(</font>U2 DOmega<font color=Cyan>,</font> Maybe Double<font color=Cyan>,</font> Integer<font color=Cyan>)</font>
<a name="line-445"></a><font color=Blue>newsynth_stats</font> prec theta g <font color=Red>=</font> dynamic_fixedprec2 digits f prec theta <font color=Green><u>where</u></font>
<a name="line-446"></a>  digits <font color=Red>=</font> ceiling <font color=Cyan>(</font><font color=Magenta>10</font> <font color=Cyan>+</font> <font color=Magenta>2</font> <font color=Cyan>*</font> prec <font color=Cyan>*</font> logBase <font color=Magenta>10</font> <font color=Magenta>2</font><font color=Cyan>)</font>
<a name="line-447"></a>  f prec theta <font color=Red>=</font> <font color=Cyan>(</font>m<font color=Cyan>,</font> err<font color=Cyan>,</font> ct<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-448"></a>    <font color=Cyan>(</font><font color=Cyan>(</font>m<font color=Cyan>,</font> err<font color=Cyan>)</font><font color=Cyan>,</font> ct<font color=Cyan>)</font> <font color=Red>=</font> keeptrying_count <font color=Cyan>(</font>newsynth_step prec theta<font color=Cyan>)</font> g
<a name="line-449"></a>
<a name="line-450"></a><a name="newsynth_gates"></a><font color=Blue><i>-- | A version of 'newsynth' that returns a list of gates instead of a</i></font>
<a name="line-451"></a><font color=Blue><i>-- matrix. The inputs are the same as for 'newsynth'.</i></font>
<a name="line-452"></a><font color=Blue><i>-- </i></font>
<a name="line-453"></a><font color=Blue><i>-- Note: the list of gates will be returned in right-to-left order,</i></font>
<a name="line-454"></a><font color=Blue><i>-- i.e., as in the mathematical notation for matrix multiplication.</i></font>
<a name="line-455"></a><font color=Blue><i>-- This is the opposite of the quantum circuit notation.</i></font>
<a name="line-456"></a><font color=Blue>newsynth_gates</font> <font color=Red>::</font> <font color=Cyan>(</font>RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> Double <font color=Red>-&gt;</font> SymReal <font color=Red>-&gt;</font> g <font color=Red>-&gt;</font> <font color=Red>[</font>Gate<font color=Red>]</font>
<a name="line-457"></a><font color=Blue>newsynth_gates</font> prec theta g <font color=Red>=</font> synthesis_u2 <font color=Cyan>(</font>newsynth prec theta g<font color=Cyan>)</font>
</pre>
</body>
</html>